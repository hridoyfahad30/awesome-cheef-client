import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/darkreader/darkreader.js
var require_darkreader = __commonJS({
  "node_modules/darkreader/darkreader.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.DarkReader = {}));
    })(exports, function(exports2) {
      "use strict";
      var __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step(
            (generator = generator.apply(thisArg, _arguments || [])).next()
          );
        });
      }
      function __generator(thisArg, body) {
        var _ = {
          label: 0,
          sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          },
          trys: [],
          ops: []
        }, f, y, t, g;
        return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(
          s ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      }
      function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      }
      var MessageType;
      (function(MessageType2) {
        MessageType2["UI_GET_DATA"] = "ui-get-data";
        MessageType2["UI_SUBSCRIBE_TO_CHANGES"] = "ui-subscribe-to-changes";
        MessageType2["UI_UNSUBSCRIBE_FROM_CHANGES"] = "ui-unsubscribe-from-changes";
        MessageType2["UI_CHANGE_SETTINGS"] = "ui-change-settings";
        MessageType2["UI_SET_THEME"] = "ui-set-theme";
        MessageType2["UI_SET_SHORTCUT"] = "ui-set-shortcut";
        MessageType2["UI_TOGGLE_ACTIVE_TAB"] = "ui-toggle-active-tab";
        MessageType2["UI_MARK_NEWS_AS_READ"] = "ui-mark-news-as-read";
        MessageType2["UI_MARK_NEWS_AS_DISPLAYED"] = "ui-mark-news-as-displayed";
        MessageType2["UI_LOAD_CONFIG"] = "ui-load-config";
        MessageType2["UI_APPLY_DEV_DYNAMIC_THEME_FIXES"] = "ui-apply-dev-dynamic-theme-fixes";
        MessageType2["UI_RESET_DEV_DYNAMIC_THEME_FIXES"] = "ui-reset-dev-dynamic-theme-fixes";
        MessageType2["UI_APPLY_DEV_INVERSION_FIXES"] = "ui-apply-dev-inversion-fixes";
        MessageType2["UI_RESET_DEV_INVERSION_FIXES"] = "ui-reset-dev-inversion-fixes";
        MessageType2["UI_APPLY_DEV_STATIC_THEMES"] = "ui-apply-dev-static-themes";
        MessageType2["UI_RESET_DEV_STATIC_THEMES"] = "ui-reset-dev-static-themes";
        MessageType2["UI_SAVE_FILE"] = "ui-save-file";
        MessageType2["UI_REQUEST_EXPORT_CSS"] = "ui-request-export-css";
        MessageType2["UI_COLOR_SCHEME_CHANGE"] = "ui-color-scheme-change";
        MessageType2["BG_CHANGES"] = "bg-changes";
        MessageType2["BG_ADD_CSS_FILTER"] = "bg-add-css-filter";
        MessageType2["BG_ADD_STATIC_THEME"] = "bg-add-static-theme";
        MessageType2["BG_ADD_SVG_FILTER"] = "bg-add-svg-filter";
        MessageType2["BG_ADD_DYNAMIC_THEME"] = "bg-add-dynamic-theme";
        MessageType2["BG_EXPORT_CSS"] = "bg-export-css";
        MessageType2["BG_UNSUPPORTED_SENDER"] = "bg-unsupported-sender";
        MessageType2["BG_CLEAN_UP"] = "bg-clean-up";
        MessageType2["BG_RELOAD"] = "bg-reload";
        MessageType2["BG_FETCH_RESPONSE"] = "bg-fetch-response";
        MessageType2["BG_UI_UPDATE"] = "bg-ui-update";
        MessageType2["BG_CSS_UPDATE"] = "bg-css-update";
        MessageType2["CS_COLOR_SCHEME_CHANGE"] = "cs-color-scheme-change";
        MessageType2["CS_FRAME_CONNECT"] = "cs-frame-connect";
        MessageType2["CS_FRAME_FORGET"] = "cs-frame-forget";
        MessageType2["CS_FRAME_FREEZE"] = "cs-frame-freeze";
        MessageType2["CS_FRAME_RESUME"] = "cs-frame-resume";
        MessageType2["CS_EXPORT_CSS_RESPONSE"] = "cs-export-css-response";
        MessageType2["CS_FETCH"] = "cs-fetch";
        MessageType2["CS_DARK_THEME_DETECTED"] = "cs-dark-theme-detected";
        MessageType2["CS_DARK_THEME_NOT_DETECTED"] = "cs-dark-theme-not-detected";
        MessageType2["CS_LOG"] = "cs-log";
      })(MessageType || (MessageType = {}));
      var isNavigatorDefined = typeof navigator !== "undefined";
      var userAgent = isNavigatorDefined ? navigator.userAgentData && Array.isArray(navigator.userAgentData.brands) ? navigator.userAgentData.brands.map(function(brand) {
        return "".concat(brand.brand.toLowerCase(), " ").concat(brand.version);
      }).join(" ") : navigator.userAgent.toLowerCase() : "some useragent";
      var platform = isNavigatorDefined ? navigator.userAgentData && typeof navigator.userAgentData.platform === "string" ? navigator.userAgentData.platform.toLowerCase() : navigator.platform.toLowerCase() : "some platform";
      var isChromium = userAgent.includes("chrome") || userAgent.includes("chromium");
      var isThunderbird = userAgent.includes("thunderbird");
      var isFirefox = userAgent.includes("firefox") || userAgent.includes("librewolf") || isThunderbird;
      userAgent.includes("vivaldi");
      userAgent.includes("yabrowser");
      userAgent.includes("opr") || userAgent.includes("opera");
      userAgent.includes("edg");
      var isSafari = userAgent.includes("safari") && !isChromium;
      var isWindows = platform.startsWith("win");
      var isMacOS = platform.startsWith("mac");
      isNavigatorDefined && navigator.userAgentData ? navigator.userAgentData.mobile : userAgent.includes("mobile");
      var isShadowDomSupported = typeof ShadowRoot === "function";
      var isMatchMediaChangeEventListenerSupported = typeof MediaQueryList === "function" && typeof MediaQueryList.prototype.addEventListener === "function";
      (function() {
        var m = userAgent.match(/chrom(?:e|ium)(?:\/| )([^ ]+)/);
        if (m && m[1]) {
          return m[1];
        }
        return "";
      })();
      (function() {
        var m = userAgent.match(/(?:firefox|librewolf)(?:\/| )([^ ]+)/);
        if (m && m[1]) {
          return m[1];
        }
        return "";
      })();
      var isDefinedSelectorSupported = function() {
        try {
          document.querySelector(":defined");
          return true;
        } catch (err) {
          return false;
        }
      }();
      var isCSSColorSchemePropSupported = function() {
        if (typeof document === "undefined") {
          return false;
        }
        var el = document.createElement("div");
        el.setAttribute("style", "color-scheme: dark");
        return el.style && el.style.colorScheme === "dark";
      }();
      function getOKResponse(url, mimeType, origin) {
        return __awaiter(this, void 0, void 0, function() {
          var response;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [
                  4,
                  fetch(url, {
                    cache: "force-cache",
                    credentials: "omit",
                    referrer: origin
                  })
                ];
              case 1:
                response = _a.sent();
                if (isFirefox && mimeType === "text/css" && url.startsWith("moz-extension://") && url.endsWith(".css")) {
                  return [2, response];
                }
                if (mimeType && !response.headers.get("Content-Type").startsWith(mimeType)) {
                  throw new Error(
                    "Mime type mismatch when loading ".concat(url)
                  );
                }
                if (!response.ok) {
                  throw new Error(
                    "Unable to load ".concat(url, " ").concat(response.status, " ").concat(response.statusText)
                  );
                }
                return [2, response];
            }
          });
        });
      }
      function loadAsDataURL(url, mimeType) {
        return __awaiter(this, void 0, void 0, function() {
          var response;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, getOKResponse(url, mimeType)];
              case 1:
                response = _a.sent();
                return [4, readResponseAsDataURL(response)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      }
      function readResponseAsDataURL(response) {
        return __awaiter(this, void 0, void 0, function() {
          var blob, dataURL;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, response.blob()];
              case 1:
                blob = _a.sent();
                return [
                  4,
                  new Promise(function(resolve) {
                    var reader = new FileReader();
                    reader.onloadend = function() {
                      return resolve(reader.result);
                    };
                    reader.readAsDataURL(blob);
                  })
                ];
              case 2:
                dataURL = _a.sent();
                return [2, dataURL];
            }
          });
        });
      }
      var throwCORSError = function(url) {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [
              2,
              Promise.reject(
                new Error(
                  [
                    "Embedded Dark Reader cannot access a cross-origin resource",
                    url,
                    "Overview your URLs and CORS policies or use",
                    "`DarkReader.setFetchMethod(fetch: (url) => Promise<Response>))`.",
                    "See if using `DarkReader.setFetchMethod(window.fetch)`",
                    "before `DarkReader.enable()` works."
                  ].join(" ")
                )
              )
            ];
          });
        });
      };
      var fetcher = throwCORSError;
      function setFetchMethod$1(fetch2) {
        if (fetch2) {
          fetcher = fetch2;
        } else {
          fetcher = throwCORSError;
        }
      }
      function callFetchMethod(url) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, fetcher(url)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      }
      if (!window.chrome) {
        window.chrome = {};
      }
      if (!chrome.runtime) {
        chrome.runtime = {};
      }
      var messageListeners = /* @__PURE__ */ new Set();
      function sendMessage() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var id_1, _a, url, responseType, response, text_1, error_1;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!(args[0] && args[0].type === MessageType.CS_FETCH))
                  return [3, 8];
                id_1 = args[0].id;
                _b.label = 1;
              case 1:
                _b.trys.push([1, 7, , 8]);
                _a = args[0].data, url = _a.url, responseType = _a.responseType;
                return [4, callFetchMethod(url)];
              case 2:
                response = _b.sent();
                if (!(responseType === "data-url"))
                  return [3, 4];
                return [4, readResponseAsDataURL(response)];
              case 3:
                text_1 = _b.sent();
                return [3, 6];
              case 4:
                return [4, response.text()];
              case 5:
                text_1 = _b.sent();
                _b.label = 6;
              case 6:
                messageListeners.forEach(function(cb) {
                  return cb({
                    type: MessageType.BG_FETCH_RESPONSE,
                    data: text_1,
                    error: null,
                    id: id_1
                  });
                });
                return [3, 8];
              case 7:
                error_1 = _b.sent();
                console.error(error_1);
                messageListeners.forEach(function(cb) {
                  return cb({
                    type: MessageType.BG_FETCH_RESPONSE,
                    data: null,
                    error: error_1,
                    id: id_1
                  });
                });
                return [3, 8];
              case 8:
                return [2];
            }
          });
        });
      }
      function addMessageListener(callback) {
        messageListeners.add(callback);
      }
      if (typeof chrome.runtime.sendMessage === "function") {
        var nativeSendMessage_1 = chrome.runtime.sendMessage;
        chrome.runtime.sendMessage = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          sendMessage.apply(void 0, __spreadArray([], __read(args), false));
          nativeSendMessage_1.apply(chrome.runtime, args);
        };
      } else {
        chrome.runtime.sendMessage = sendMessage;
      }
      if (!chrome.runtime.onMessage) {
        chrome.runtime.onMessage = {};
      }
      if (typeof chrome.runtime.onMessage.addListener === "function") {
        var nativeAddListener_1 = chrome.runtime.onMessage.addListener;
        chrome.runtime.onMessage.addListener = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          addMessageListener(args[0]);
          nativeAddListener_1.apply(chrome.runtime.onMessage, args);
        };
      } else {
        chrome.runtime.onMessage.addListener = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return addMessageListener(args[0]);
        };
      }
      var ThemeEngine;
      (function(ThemeEngine2) {
        ThemeEngine2["cssFilter"] = "cssFilter";
        ThemeEngine2["svgFilter"] = "svgFilter";
        ThemeEngine2["staticTheme"] = "staticTheme";
        ThemeEngine2["dynamicTheme"] = "dynamicTheme";
      })(ThemeEngine || (ThemeEngine = {}));
      var AutomationMode;
      (function(AutomationMode2) {
        AutomationMode2["NONE"] = "";
        AutomationMode2["TIME"] = "time";
        AutomationMode2["SYSTEM"] = "system";
        AutomationMode2["LOCATION"] = "location";
      })(AutomationMode || (AutomationMode = {}));
      var DEFAULT_COLORS = {
        darkScheme: {
          background: "#181a1b",
          text: "#e8e6e3"
        },
        lightScheme: {
          background: "#dcdad7",
          text: "#181a1b"
        }
      };
      var DEFAULT_THEME = {
        mode: 1,
        brightness: 100,
        contrast: 100,
        grayscale: 0,
        sepia: 0,
        useFont: false,
        fontFamily: isMacOS ? "Helvetica Neue" : isWindows ? "Segoe UI" : "Open Sans",
        textStroke: 0,
        engine: ThemeEngine.dynamicTheme,
        stylesheet: "",
        darkSchemeBackgroundColor: DEFAULT_COLORS.darkScheme.background,
        darkSchemeTextColor: DEFAULT_COLORS.darkScheme.text,
        lightSchemeBackgroundColor: DEFAULT_COLORS.lightScheme.background,
        lightSchemeTextColor: DEFAULT_COLORS.lightScheme.text,
        scrollbarColor: isMacOS ? "" : "auto",
        selectionColor: "auto",
        styleSystemControls: !isCSSColorSchemePropSupported,
        lightColorScheme: "Default",
        darkColorScheme: "Default",
        immediateModify: false
      };
      ({
        enabled: true,
        fetchNews: true,
        theme: DEFAULT_THEME,
        presets: [],
        customThemes: [],
        siteList: [],
        siteListEnabled: [],
        applyToListedOnly: false,
        changeBrowserTheme: false,
        syncSettings: true,
        syncSitesFixes: false,
        automation: {
          enabled: false,
          mode: AutomationMode.NONE,
          behavior: "OnOff"
        },
        time: {
          activation: "18:00",
          deactivation: "9:00"
        },
        location: {
          latitude: null,
          longitude: null
        },
        previewNewDesign: false,
        enableForPDF: true,
        enableForProtectedPages: false,
        enableContextMenus: false,
        detectDarkTheme: false
      });
      function isArrayLike(items) {
        return items.length != null;
      }
      function forEach(items, iterator) {
        var e_1, _a;
        if (isArrayLike(items)) {
          for (var i = 0, len = items.length; i < len; i++) {
            iterator(items[i]);
          }
        } else {
          try {
            for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
              var item = items_1_1.value;
              iterator(item);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (items_1_1 && !items_1_1.done && (_a = items_1.return))
                _a.call(items_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      }
      function push(array, addition) {
        forEach(addition, function(a) {
          return array.push(a);
        });
      }
      function toArray(items) {
        var results = [];
        for (var i = 0, len = items.length; i < len; i++) {
          results.push(items[i]);
        }
        return results;
      }
      function logInfo() {
      }
      function logWarn() {
      }
      function throttle(callback) {
        var pending = false;
        var frameId = null;
        var lastArgs;
        var throttled = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          lastArgs = args;
          if (frameId) {
            pending = true;
          } else {
            callback.apply(
              void 0,
              __spreadArray([], __read(lastArgs), false)
            );
            frameId = requestAnimationFrame(function() {
              frameId = null;
              if (pending) {
                callback.apply(
                  void 0,
                  __spreadArray([], __read(lastArgs), false)
                );
                pending = false;
              }
            });
          }
        };
        var cancel = function() {
          cancelAnimationFrame(frameId);
          pending = false;
          frameId = null;
        };
        return Object.assign(throttled, { cancel });
      }
      function createAsyncTasksQueue() {
        var tasks = [];
        var frameId = null;
        function runTasks() {
          var task;
          while (task = tasks.shift()) {
            task();
          }
          frameId = null;
        }
        function add(task) {
          tasks.push(task);
          if (!frameId) {
            frameId = requestAnimationFrame(runTasks);
          }
        }
        function cancel() {
          tasks.splice(0);
          cancelAnimationFrame(frameId);
          frameId = null;
        }
        return { add, cancel };
      }
      function getDuration(time) {
        var duration = 0;
        if (time.seconds) {
          duration += time.seconds * 1e3;
        }
        if (time.minutes) {
          duration += time.minutes * 60 * 1e3;
        }
        if (time.hours) {
          duration += time.hours * 60 * 60 * 1e3;
        }
        if (time.days) {
          duration += time.days * 24 * 60 * 60 * 1e3;
        }
        return duration;
      }
      function removeNode(node) {
        node && node.parentNode && node.parentNode.removeChild(node);
      }
      function watchForNodePosition(node, mode, onRestore) {
        if (onRestore === void 0) {
          onRestore = Function.prototype;
        }
        var MAX_ATTEMPTS_COUNT = 10;
        var RETRY_TIMEOUT = getDuration({ seconds: 2 });
        var ATTEMPTS_INTERVAL = getDuration({ seconds: 10 });
        var prevSibling = node.previousSibling;
        var parent = node.parentNode;
        if (!parent) {
          throw new Error(
            "Unable to watch for node position: parent element not found"
          );
        }
        if (mode === "prev-sibling" && !prevSibling) {
          throw new Error(
            "Unable to watch for node position: there is no previous sibling"
          );
        }
        var attempts = 0;
        var start = null;
        var timeoutId = null;
        var restore = throttle(function() {
          if (timeoutId) {
            return;
          }
          attempts++;
          var now = Date.now();
          if (start == null) {
            start = now;
          } else if (attempts >= MAX_ATTEMPTS_COUNT) {
            if (now - start < ATTEMPTS_INTERVAL) {
              timeoutId = setTimeout(function() {
                start = null;
                attempts = 0;
                timeoutId = null;
                restore();
              }, RETRY_TIMEOUT);
              return;
            }
            start = now;
            attempts = 1;
          }
          if (mode === "parent") {
            if (prevSibling && prevSibling.parentNode !== parent) {
              stop();
              return;
            }
          }
          if (mode === "prev-sibling") {
            if (prevSibling.parentNode == null) {
              stop();
              return;
            }
            if (prevSibling.parentNode !== parent) {
              updateParent(prevSibling.parentNode);
            }
          }
          parent.insertBefore(
            node,
            prevSibling ? prevSibling.nextSibling : parent.firstChild
          );
          observer2.takeRecords();
          onRestore && onRestore();
        });
        var observer2 = new MutationObserver(function() {
          if (mode === "parent" && node.parentNode !== parent || mode === "prev-sibling" && node.previousSibling !== prevSibling) {
            restore();
          }
        });
        var run = function() {
          observer2.observe(parent, { childList: true });
        };
        var stop = function() {
          clearTimeout(timeoutId);
          observer2.disconnect();
          restore.cancel();
        };
        var skip = function() {
          observer2.takeRecords();
        };
        var updateParent = function(parentNode) {
          parent = parentNode;
          stop();
          run();
        };
        run();
        return { run, stop, skip };
      }
      function iterateShadowHosts(root, iterator) {
        if (root == null) {
          return;
        }
        var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
          acceptNode: function(node2) {
            return node2.shadowRoot == null ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
          }
        });
        for (var node = root.shadowRoot ? walker.currentNode : walker.nextNode(); node != null; node = walker.nextNode()) {
          if (node.classList.contains("surfingkeys_hints_host")) {
            continue;
          }
          iterator(node);
          iterateShadowHosts(node.shadowRoot, iterator);
        }
      }
      var isDOMReady = function() {
        return document.readyState === "complete" || document.readyState === "interactive";
      };
      function setIsDOMReady(newFunc) {
        isDOMReady = newFunc;
      }
      var readyStateListeners = /* @__PURE__ */ new Set();
      function addDOMReadyListener(listener) {
        isDOMReady() ? listener() : readyStateListeners.add(listener);
      }
      function removeDOMReadyListener(listener) {
        readyStateListeners.delete(listener);
      }
      function isReadyStateComplete() {
        return document.readyState === "complete";
      }
      var readyStateCompleteListeners = /* @__PURE__ */ new Set();
      function addReadyStateCompleteListener(listener) {
        isReadyStateComplete() ? listener() : readyStateCompleteListeners.add(listener);
      }
      function cleanReadyStateCompleteListeners() {
        readyStateCompleteListeners.clear();
      }
      if (!isDOMReady()) {
        var onReadyStateChange_1 = function() {
          if (isDOMReady()) {
            readyStateListeners.forEach(function(listener) {
              return listener();
            });
            readyStateListeners.clear();
            if (isReadyStateComplete()) {
              document.removeEventListener(
                "readystatechange",
                onReadyStateChange_1
              );
              readyStateCompleteListeners.forEach(function(listener) {
                return listener();
              });
              readyStateCompleteListeners.clear();
            }
          }
        };
        document.addEventListener("readystatechange", onReadyStateChange_1);
      }
      var HUGE_MUTATIONS_COUNT = 1e3;
      function isHugeMutation(mutations) {
        if (mutations.length > HUGE_MUTATIONS_COUNT) {
          return true;
        }
        var addedNodesCount = 0;
        for (var i = 0; i < mutations.length; i++) {
          addedNodesCount += mutations[i].addedNodes.length;
          if (addedNodesCount > HUGE_MUTATIONS_COUNT) {
            return true;
          }
        }
        return false;
      }
      function getElementsTreeOperations(mutations) {
        var additions = /* @__PURE__ */ new Set();
        var deletions = /* @__PURE__ */ new Set();
        var moves = /* @__PURE__ */ new Set();
        mutations.forEach(function(m) {
          forEach(m.addedNodes, function(n) {
            if (n instanceof Element && n.isConnected) {
              additions.add(n);
            }
          });
          forEach(m.removedNodes, function(n) {
            if (n instanceof Element) {
              if (n.isConnected) {
                moves.add(n);
                additions.delete(n);
              } else {
                deletions.add(n);
              }
            }
          });
        });
        var duplicateAdditions = [];
        var duplicateDeletions = [];
        additions.forEach(function(node) {
          if (additions.has(node.parentElement)) {
            duplicateAdditions.push(node);
          }
        });
        deletions.forEach(function(node) {
          if (deletions.has(node.parentElement)) {
            duplicateDeletions.push(node);
          }
        });
        duplicateAdditions.forEach(function(node) {
          return additions.delete(node);
        });
        duplicateDeletions.forEach(function(node) {
          return deletions.delete(node);
        });
        return { additions, moves, deletions };
      }
      var optimizedTreeObservers = /* @__PURE__ */ new Map();
      var optimizedTreeCallbacks = /* @__PURE__ */ new WeakMap();
      function createOptimizedTreeObserver(root, callbacks) {
        var observer2;
        var observerCallbacks;
        var domReadyListener;
        if (optimizedTreeObservers.has(root)) {
          observer2 = optimizedTreeObservers.get(root);
          observerCallbacks = optimizedTreeCallbacks.get(observer2);
        } else {
          var hadHugeMutationsBefore_1 = false;
          var subscribedForReadyState_1 = false;
          observer2 = new MutationObserver(function(mutations) {
            if (isHugeMutation(mutations)) {
              if (!hadHugeMutationsBefore_1 || isDOMReady()) {
                observerCallbacks.forEach(function(_a) {
                  var onHugeMutations = _a.onHugeMutations;
                  return onHugeMutations(root);
                });
              } else if (!subscribedForReadyState_1) {
                domReadyListener = function() {
                  return observerCallbacks.forEach(function(_a) {
                    var onHugeMutations = _a.onHugeMutations;
                    return onHugeMutations(root);
                  });
                };
                addDOMReadyListener(domReadyListener);
                subscribedForReadyState_1 = true;
              }
              hadHugeMutationsBefore_1 = true;
            } else {
              var elementsOperations_1 = getElementsTreeOperations(mutations);
              observerCallbacks.forEach(function(_a) {
                var onMinorMutations = _a.onMinorMutations;
                return onMinorMutations(elementsOperations_1);
              });
            }
          });
          observer2.observe(root, { childList: true, subtree: true });
          optimizedTreeObservers.set(root, observer2);
          observerCallbacks = /* @__PURE__ */ new Set();
          optimizedTreeCallbacks.set(observer2, observerCallbacks);
        }
        observerCallbacks.add(callbacks);
        return {
          disconnect: function() {
            observerCallbacks.delete(callbacks);
            if (domReadyListener) {
              removeDOMReadyListener(domReadyListener);
            }
            if (observerCallbacks.size === 0) {
              observer2.disconnect();
              optimizedTreeCallbacks.delete(observer2);
              optimizedTreeObservers.delete(root);
            }
          }
        };
      }
      var anchor;
      var parsedURLCache = /* @__PURE__ */ new Map();
      function fixBaseURL($url) {
        if (!anchor) {
          anchor = document.createElement("a");
        }
        anchor.href = $url;
        return anchor.href;
      }
      function parseURL($url, $base) {
        if ($base === void 0) {
          $base = null;
        }
        var key = "".concat($url).concat($base ? ";".concat($base) : "");
        if (parsedURLCache.has(key)) {
          return parsedURLCache.get(key);
        }
        if ($base) {
          var parsedURL_1 = new URL($url, fixBaseURL($base));
          parsedURLCache.set(key, parsedURL_1);
          return parsedURL_1;
        }
        var parsedURL = new URL(fixBaseURL($url));
        parsedURLCache.set($url, parsedURL);
        return parsedURL;
      }
      function getAbsoluteURL($base, $relative) {
        if ($relative.match(/^data\\?\:/)) {
          return $relative;
        }
        if (/^\/\//.test($relative)) {
          return "".concat(location.protocol).concat($relative);
        }
        var b = parseURL($base);
        var a = parseURL($relative, b.href);
        return a.href;
      }
      function isRelativeHrefOnAbsolutePath(href) {
        if (href.startsWith("data:")) {
          return true;
        }
        var url = parseURL(href);
        if (url.protocol !== location.protocol) {
          return false;
        }
        if (url.hostname !== location.hostname) {
          return false;
        }
        if (url.port !== location.port) {
          return false;
        }
        return url.pathname === location.pathname;
      }
      function iterateCSSRules(rules, iterate, onMediaRuleError) {
        forEach(rules, function(rule) {
          if (rule.selectorText) {
            iterate(rule);
          } else if (rule.href) {
            try {
              iterateCSSRules(
                rule.styleSheet.cssRules,
                iterate,
                onMediaRuleError
              );
            } catch (err) {
              logInfo("Found a non-loaded link.");
              onMediaRuleError && onMediaRuleError();
            }
          } else if (rule.media) {
            var media = Array.from(rule.media);
            var isScreenOrAllOrQuery = media.some(function(m) {
              return m.startsWith("screen") || m.startsWith("all") || m.startsWith("(");
            });
            var isPrintOrSpeech = media.some(function(m) {
              return m.startsWith("print") || m.startsWith("speech");
            });
            if (isScreenOrAllOrQuery || !isPrintOrSpeech) {
              iterateCSSRules(rule.cssRules, iterate, onMediaRuleError);
            }
          } else if (rule.conditionText) {
            if (CSS.supports(rule.conditionText)) {
              iterateCSSRules(rule.cssRules, iterate, onMediaRuleError);
            }
          } else {
            logWarn("CSSRule type not supported", rule);
          }
        });
      }
      var shorthandVarDependantProperties = [
        "background",
        "border",
        "border-color",
        "border-bottom",
        "border-left",
        "border-right",
        "border-top",
        "outline",
        "outline-color"
      ];
      var shorthandVarDepPropRegexps = isSafari ? shorthandVarDependantProperties.map(function(prop) {
        var regexp = new RegExp("".concat(prop, ":\\s*(.*?)\\s*;"));
        return [prop, regexp];
      }) : null;
      function iterateCSSDeclarations(style, iterate) {
        forEach(style, function(property) {
          var value = style.getPropertyValue(property).trim();
          if (!value) {
            return;
          }
          iterate(property, value);
        });
        var cssText = style.cssText;
        if (cssText.includes("var(")) {
          if (isSafari) {
            shorthandVarDepPropRegexps.forEach(function(_a) {
              var _b = __read(_a, 2), prop = _b[0], regexp = _b[1];
              var match = cssText.match(regexp);
              if (match && match[1]) {
                var val = match[1].trim();
                iterate(prop, val);
              }
            });
          } else {
            shorthandVarDependantProperties.forEach(function(prop) {
              var val = style.getPropertyValue(prop);
              if (val && val.includes("var(")) {
                iterate(prop, val);
              }
            });
          }
        }
      }
      var cssURLRegex = /url\((('.*?')|(".*?")|([^\)]*?))\)/g;
      var cssImportRegex = /@import\s*(url\()?(('.+?')|(".+?")|([^\)]*?))\)? ?(screen)?;?/gi;
      function getCSSURLValue(cssURL) {
        return cssURL.trim().replace(/[\n\r\\]+/g, "").replace(/^url\((.*)\)$/, "$1").trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1").replace(/(?:\\(.))/g, "$1");
      }
      function getCSSBaseBath(url) {
        var cssURL = parseURL(url);
        return "".concat(cssURL.origin).concat(
          cssURL.pathname.replace(/\?.*$/, "").replace(/(\/)([^\/]+)$/i, "$1")
        );
      }
      function replaceCSSRelativeURLsWithAbsolute($css, cssBasePath) {
        return $css.replace(cssURLRegex, function(match) {
          var pathValue = getCSSURLValue(match);
          try {
            return "url('".concat(
              getAbsoluteURL(cssBasePath, pathValue),
              "')"
            );
          } catch (err) {
            return match;
          }
        });
      }
      var cssCommentsRegex = /\/\*[\s\S]*?\*\//g;
      function removeCSSComments($css) {
        return $css.replace(cssCommentsRegex, "");
      }
      var fontFaceRegex = /@font-face\s*{[^}]*}/g;
      function replaceCSSFontFace($css) {
        return $css.replace(fontFaceRegex, "");
      }
      function evalMath(expression) {
        var rpnStack = [];
        var workingStack = [];
        var lastToken;
        for (var i = 0, len = expression.length; i < len; i++) {
          var token = expression[i];
          if (!token || token === " ") {
            continue;
          }
          if (operators.has(token)) {
            var op = operators.get(token);
            while (workingStack.length) {
              var currentOp = operators.get(workingStack[0]);
              if (!currentOp) {
                break;
              }
              if (op.lessOrEqualThan(currentOp)) {
                rpnStack.push(workingStack.shift());
              } else {
                break;
              }
            }
            workingStack.unshift(token);
          } else if (!lastToken || operators.has(lastToken)) {
            rpnStack.push(token);
          } else {
            rpnStack[rpnStack.length - 1] += token;
          }
          lastToken = token;
        }
        rpnStack.push.apply(
          rpnStack,
          __spreadArray([], __read(workingStack), false)
        );
        var stack = [];
        for (var i = 0, len = rpnStack.length; i < len; i++) {
          var op = operators.get(rpnStack[i]);
          if (op) {
            var args = stack.splice(0, 2);
            stack.push(op.exec(args[1], args[0]));
          } else {
            stack.unshift(parseFloat(rpnStack[i]));
          }
        }
        return stack[0];
      }
      var Operator = function() {
        function Operator2(precedence, method) {
          this.precendce = precedence;
          this.execMethod = method;
        }
        Operator2.prototype.exec = function(left, right) {
          return this.execMethod(left, right);
        };
        Operator2.prototype.lessOrEqualThan = function(op) {
          return this.precendce <= op.precendce;
        };
        return Operator2;
      }();
      var operators = /* @__PURE__ */ new Map([
        [
          "+",
          new Operator(1, function(left, right) {
            return left + right;
          })
        ],
        [
          "-",
          new Operator(1, function(left, right) {
            return left - right;
          })
        ],
        [
          "*",
          new Operator(2, function(left, right) {
            return left * right;
          })
        ],
        [
          "/",
          new Operator(2, function(left, right) {
            return left / right;
          })
        ]
      ]);
      function getMatches(regex, input, group) {
        if (group === void 0) {
          group = 0;
        }
        var matches = [];
        var m;
        while (m = regex.exec(input)) {
          matches.push(m[group]);
        }
        return matches;
      }
      function formatCSS(text) {
        function trimLeft(text2) {
          return text2.replace(/^\s+/, "");
        }
        function getIndent(depth2) {
          if (depth2 === 0) {
            return "";
          }
          return " ".repeat(4 * depth2);
        }
        if (text.length < 5e4) {
          var emptyRuleRegexp = /[^{}]+{\s*}/;
          while (emptyRuleRegexp.test(text)) {
            text = text.replace(emptyRuleRegexp, "");
          }
        }
        var css = text.replace(/\s{2,}/g, " ").replace(/\{/g, "{\n").replace(/\}/g, "\n}\n").replace(/\;(?![^\(|\"]*(\)|\"))/g, ";\n").replace(/\,(?![^\(|\"]*(\)|\"))/g, ",\n").replace(/\n\s*\n/g, "\n").split("\n");
        var depth = 0;
        var formatted = [];
        for (var x = 0, len = css.length; x < len; x++) {
          var line = "".concat(css[x], "\n");
          if (line.includes("{")) {
            formatted.push(getIndent(depth++) + trimLeft(line));
          } else if (line.includes("}")) {
            formatted.push(getIndent(--depth) + trimLeft(line));
          } else {
            formatted.push(getIndent(depth) + trimLeft(line));
          }
        }
        return formatted.join("").trim();
      }
      function getParenthesesRange(input, searchStartIndex) {
        if (searchStartIndex === void 0) {
          searchStartIndex = 0;
        }
        var length = input.length;
        var depth = 0;
        var firstOpenIndex = -1;
        for (var i = searchStartIndex; i < length; i++) {
          if (depth === 0) {
            var openIndex = input.indexOf("(", i);
            if (openIndex < 0) {
              break;
            }
            firstOpenIndex = openIndex;
            depth++;
            i = openIndex;
          } else {
            var closingIndex = input.indexOf(")", i);
            if (closingIndex < 0) {
              break;
            }
            var openIndex = input.indexOf("(", i);
            if (openIndex < 0 || closingIndex < openIndex) {
              depth--;
              if (depth === 0) {
                return { start: firstOpenIndex, end: closingIndex + 1 };
              }
              i = closingIndex;
            } else {
              depth++;
              i = openIndex;
            }
          }
        }
        return null;
      }
      var hslaParseCache = /* @__PURE__ */ new Map();
      var rgbaParseCache = /* @__PURE__ */ new Map();
      function parseColorWithCache($color) {
        $color = $color.trim();
        if (rgbaParseCache.has($color)) {
          return rgbaParseCache.get($color);
        }
        if ($color.includes("calc(")) {
          $color = lowerCalcExpression($color);
        }
        var color = parse($color);
        color && rgbaParseCache.set($color, color);
        return color;
      }
      function parseToHSLWithCache(color) {
        if (hslaParseCache.has(color)) {
          return hslaParseCache.get(color);
        }
        var rgb = parseColorWithCache(color);
        if (!rgb) {
          return null;
        }
        var hsl = rgbToHSL(rgb);
        hslaParseCache.set(color, hsl);
        return hsl;
      }
      function clearColorCache() {
        hslaParseCache.clear();
        rgbaParseCache.clear();
      }
      function hslToRGB(_a) {
        var h = _a.h, s = _a.s, l = _a.l, _b = _a.a, a = _b === void 0 ? 1 : _b;
        if (s === 0) {
          var _c = __read(
            [l, l, l].map(function(x2) {
              return Math.round(x2 * 255);
            }),
            3
          ), r_1 = _c[0], b_1 = _c[1], g_1 = _c[2];
          return { r: r_1, g: g_1, b: b_1, a };
        }
        var c = (1 - Math.abs(2 * l - 1)) * s;
        var x = c * (1 - Math.abs(h / 60 % 2 - 1));
        var m = l - c / 2;
        var _d = __read(
          (h < 60 ? [c, x, 0] : h < 120 ? [x, c, 0] : h < 180 ? [0, c, x] : h < 240 ? [0, x, c] : h < 300 ? [x, 0, c] : [c, 0, x]).map(function(n) {
            return Math.round((n + m) * 255);
          }),
          3
        ), r = _d[0], g = _d[1], b = _d[2];
        return { r, g, b, a };
      }
      function rgbToHSL(_a) {
        var r255 = _a.r, g255 = _a.g, b255 = _a.b, _b = _a.a, a = _b === void 0 ? 1 : _b;
        var r = r255 / 255;
        var g = g255 / 255;
        var b = b255 / 255;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var c = max - min;
        var l = (max + min) / 2;
        if (c === 0) {
          return { h: 0, s: 0, l, a };
        }
        var h = (max === r ? (g - b) / c % 6 : max === g ? (b - r) / c + 2 : (r - g) / c + 4) * 60;
        if (h < 0) {
          h += 360;
        }
        var s = c / (1 - Math.abs(2 * l - 1));
        return { h, s, l, a };
      }
      function toFixed(n, digits) {
        if (digits === void 0) {
          digits = 0;
        }
        var fixed = n.toFixed(digits);
        if (digits === 0) {
          return fixed;
        }
        var dot = fixed.indexOf(".");
        if (dot >= 0) {
          var zerosMatch = fixed.match(/0+$/);
          if (zerosMatch) {
            if (zerosMatch.index === dot + 1) {
              return fixed.substring(0, dot);
            }
            return fixed.substring(0, zerosMatch.index);
          }
        }
        return fixed;
      }
      function rgbToString(rgb) {
        var r = rgb.r, g = rgb.g, b = rgb.b, a = rgb.a;
        if (a != null && a < 1) {
          return "rgba(".concat(toFixed(r), ", ").concat(toFixed(g), ", ").concat(toFixed(b), ", ").concat(toFixed(a, 2), ")");
        }
        return "rgb(".concat(toFixed(r), ", ").concat(toFixed(g), ", ").concat(toFixed(b), ")");
      }
      function rgbToHexString(_a) {
        var r = _a.r, g = _a.g, b = _a.b, a = _a.a;
        return "#".concat(
          (a != null && a < 1 ? [r, g, b, Math.round(a * 255)] : [r, g, b]).map(function(x) {
            return "".concat(x < 16 ? "0" : "").concat(x.toString(16));
          }).join("")
        );
      }
      function hslToString(hsl) {
        var h = hsl.h, s = hsl.s, l = hsl.l, a = hsl.a;
        if (a != null && a < 1) {
          return "hsla(".concat(toFixed(h), ", ").concat(toFixed(s * 100), "%, ").concat(toFixed(l * 100), "%, ").concat(toFixed(a, 2), ")");
        }
        return "hsl(".concat(toFixed(h), ", ").concat(toFixed(s * 100), "%, ").concat(toFixed(l * 100), "%)");
      }
      var rgbMatch = /^rgba?\([^\(\)]+\)$/;
      var hslMatch = /^hsla?\([^\(\)]+\)$/;
      var hexMatch = /^#[0-9a-f]+$/i;
      function parse($color) {
        var c = $color.trim().toLowerCase();
        if (c.match(rgbMatch)) {
          return parseRGB(c);
        }
        if (c.match(hslMatch)) {
          return parseHSL(c);
        }
        if (c.match(hexMatch)) {
          return parseHex(c);
        }
        if (knownColors.has(c)) {
          return getColorByName(c);
        }
        if (systemColors.has(c)) {
          return getSystemColor(c);
        }
        if ($color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0 };
        }
        return null;
      }
      function getNumbers($color) {
        var numbers = [];
        var prevPos = 0;
        var isMining = false;
        var startIndex = $color.indexOf("(");
        $color = $color.substring(startIndex + 1, $color.length - 1);
        for (var i = 0; i < $color.length; i++) {
          var c = $color[i];
          if (c >= "0" && c <= "9" || c === "." || c === "+" || c === "-") {
            isMining = true;
          } else if (isMining && (c === " " || c === ",")) {
            numbers.push($color.substring(prevPos, i));
            isMining = false;
            prevPos = i + 1;
          } else if (!isMining) {
            prevPos = i + 1;
          }
        }
        if (isMining) {
          numbers.push($color.substring(prevPos, $color.length));
        }
        return numbers;
      }
      function getNumbersFromString(str, range, units) {
        var raw = getNumbers(str);
        var unitsList = Object.entries(units);
        var numbers = raw.map(function(r) {
          return r.trim();
        }).map(function(r, i) {
          var n;
          var unit = unitsList.find(function(_a) {
            var _b = __read(_a, 1), u = _b[0];
            return r.endsWith(u);
          });
          if (unit) {
            n = parseFloat(r.substring(0, r.length - unit[0].length)) / unit[1] * range[i];
          } else {
            n = parseFloat(r);
          }
          if (range[i] > 1) {
            return Math.round(n);
          }
          return n;
        });
        return numbers;
      }
      var rgbRange = [255, 255, 255, 1];
      var rgbUnits = { "%": 100 };
      function parseRGB($rgb) {
        var _a = __read(getNumbersFromString($rgb, rgbRange, rgbUnits), 4), r = _a[0], g = _a[1], b = _a[2], _b = _a[3], a = _b === void 0 ? 1 : _b;
        return { r, g, b, a };
      }
      var hslRange = [360, 1, 1, 1];
      var hslUnits = { "%": 100, "deg": 360, "rad": 2 * Math.PI, "turn": 1 };
      function parseHSL($hsl) {
        var _a = __read(getNumbersFromString($hsl, hslRange, hslUnits), 4), h = _a[0], s = _a[1], l = _a[2], _b = _a[3], a = _b === void 0 ? 1 : _b;
        return hslToRGB({ h, s, l, a });
      }
      function parseHex($hex) {
        var h = $hex.substring(1);
        switch (h.length) {
          case 3:
          case 4: {
            var _a = __read(
              [0, 1, 2].map(function(i) {
                return parseInt("".concat(h[i]).concat(h[i]), 16);
              }),
              3
            ), r = _a[0], g = _a[1], b = _a[2];
            var a = h.length === 3 ? 1 : parseInt("".concat(h[3]).concat(h[3]), 16) / 255;
            return { r, g, b, a };
          }
          case 6:
          case 8: {
            var _b = __read(
              [0, 2, 4].map(function(i) {
                return parseInt(h.substring(i, i + 2), 16);
              }),
              3
            ), r = _b[0], g = _b[1], b = _b[2];
            var a = h.length === 6 ? 1 : parseInt(h.substring(6, 8), 16) / 255;
            return { r, g, b, a };
          }
        }
        return null;
      }
      function getColorByName($color) {
        var n = knownColors.get($color);
        return {
          r: n >> 16 & 255,
          g: n >> 8 & 255,
          b: n >> 0 & 255,
          a: 1
        };
      }
      function getSystemColor($color) {
        var n = systemColors.get($color);
        return {
          r: n >> 16 & 255,
          g: n >> 8 & 255,
          b: n >> 0 & 255,
          a: 1
        };
      }
      function lowerCalcExpression(color) {
        var searchIndex = 0;
        var replaceBetweenIndices = function(start, end, replacement) {
          color = color.substring(0, start) + replacement + color.substring(end);
        };
        while ((searchIndex = color.indexOf("calc(")) !== -1) {
          var range = getParenthesesRange(color, searchIndex);
          if (!range) {
            break;
          }
          var slice = color.slice(range.start + 1, range.end - 1);
          var includesPercentage = slice.includes("%");
          slice = slice.split("%").join("");
          var output = Math.round(evalMath(slice));
          replaceBetweenIndices(
            range.start - 4,
            range.end,
            output + (includesPercentage ? "%" : "")
          );
        }
        return color;
      }
      var knownColors = new Map(
        Object.entries({
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgrey: 11119017,
          darkgreen: 25600,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          grey: 8421504,
          green: 32768,
          greenyellow: 11403055,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgrey: 13882323,
          lightgreen: 9498256,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074
        })
      );
      var systemColors = new Map(
        Object.entries({
          "ActiveBorder": 3906044,
          "ActiveCaption": 0,
          "AppWorkspace": 11184810,
          "Background": 6513614,
          "ButtonFace": 16777215,
          "ButtonHighlight": 15329769,
          "ButtonShadow": 10461343,
          "ButtonText": 0,
          "CaptionText": 0,
          "GrayText": 8355711,
          "Highlight": 11720703,
          "HighlightText": 0,
          "InactiveBorder": 16777215,
          "InactiveCaption": 16777215,
          "InactiveCaptionText": 0,
          "InfoBackground": 16514245,
          "InfoText": 0,
          "Menu": 16185078,
          "MenuText": 16777215,
          "Scrollbar": 11184810,
          "ThreeDDarkShadow": 0,
          "ThreeDFace": 12632256,
          "ThreeDHighlight": 16777215,
          "ThreeDLightShadow": 16777215,
          "ThreeDShadow": 0,
          "Window": 15527148,
          "WindowFrame": 11184810,
          "WindowText": 0,
          "-webkit-focus-ring-color": 15046400
        }).map(function(_a) {
          var _b = __read(_a, 2), key = _b[0], value = _b[1];
          return [key.toLowerCase(), value];
        })
      );
      function getSRGBLightness(r, g, b) {
        return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
      }
      function scale(x, inLow, inHigh, outLow, outHigh) {
        return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
      }
      function clamp(x, min, max) {
        return Math.min(max, Math.max(min, x));
      }
      function multiplyMatrices(m1, m2) {
        var result = [];
        for (var i = 0, len = m1.length; i < len; i++) {
          result[i] = [];
          for (var j = 0, len2 = m2[0].length; j < len2; j++) {
            var sum = 0;
            for (var k = 0, len3 = m1[0].length; k < len3; k++) {
              sum += m1[i][k] * m2[k][j];
            }
            result[i][j] = sum;
          }
        }
        return result;
      }
      function createFilterMatrix(config) {
        var m = Matrix.identity();
        if (config.sepia !== 0) {
          m = multiplyMatrices(m, Matrix.sepia(config.sepia / 100));
        }
        if (config.grayscale !== 0) {
          m = multiplyMatrices(m, Matrix.grayscale(config.grayscale / 100));
        }
        if (config.contrast !== 100) {
          m = multiplyMatrices(m, Matrix.contrast(config.contrast / 100));
        }
        if (config.brightness !== 100) {
          m = multiplyMatrices(m, Matrix.brightness(config.brightness / 100));
        }
        if (config.mode === 1) {
          m = multiplyMatrices(m, Matrix.invertNHue());
        }
        return m;
      }
      function applyColorMatrix(_a, matrix) {
        var _b = __read(_a, 3), r = _b[0], g = _b[1], b = _b[2];
        var rgb = [[r / 255], [g / 255], [b / 255], [1], [1]];
        var result = multiplyMatrices(matrix, rgb);
        return [0, 1, 2].map(function(i) {
          return clamp(Math.round(result[i][0] * 255), 0, 255);
        });
      }
      var Matrix = {
        identity: function() {
          return [
            [1, 0, 0, 0, 0],
            [0, 1, 0, 0, 0],
            [0, 0, 1, 0, 0],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
          ];
        },
        invertNHue: function() {
          return [
            [0.333, -0.667, -0.667, 0, 1],
            [-0.667, 0.333, -0.667, 0, 1],
            [-0.667, -0.667, 0.333, 0, 1],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
          ];
        },
        brightness: function(v) {
          return [
            [v, 0, 0, 0, 0],
            [0, v, 0, 0, 0],
            [0, 0, v, 0, 0],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
          ];
        },
        contrast: function(v) {
          var t = (1 - v) / 2;
          return [
            [v, 0, 0, 0, t],
            [0, v, 0, 0, t],
            [0, 0, v, 0, t],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
          ];
        },
        sepia: function(v) {
          return [
            [
              0.393 + 0.607 * (1 - v),
              0.769 - 0.769 * (1 - v),
              0.189 - 0.189 * (1 - v),
              0,
              0
            ],
            [
              0.349 - 0.349 * (1 - v),
              0.686 + 0.314 * (1 - v),
              0.168 - 0.168 * (1 - v),
              0,
              0
            ],
            [
              0.272 - 0.272 * (1 - v),
              0.534 - 0.534 * (1 - v),
              0.131 + 0.869 * (1 - v),
              0,
              0
            ],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
          ];
        },
        grayscale: function(v) {
          return [
            [
              0.2126 + 0.7874 * (1 - v),
              0.7152 - 0.7152 * (1 - v),
              0.0722 - 0.0722 * (1 - v),
              0,
              0
            ],
            [
              0.2126 - 0.2126 * (1 - v),
              0.7152 + 0.2848 * (1 - v),
              0.0722 - 0.0722 * (1 - v),
              0,
              0
            ],
            [
              0.2126 - 0.2126 * (1 - v),
              0.7152 - 0.7152 * (1 - v),
              0.0722 + 0.9278 * (1 - v),
              0,
              0
            ],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1]
          ];
        }
      };
      function getBgPole(theme) {
        var isDarkScheme = theme.mode === 1;
        var prop = isDarkScheme ? "darkSchemeBackgroundColor" : "lightSchemeBackgroundColor";
        return theme[prop];
      }
      function getFgPole(theme) {
        var isDarkScheme = theme.mode === 1;
        var prop = isDarkScheme ? "darkSchemeTextColor" : "lightSchemeTextColor";
        return theme[prop];
      }
      var colorModificationCache = /* @__PURE__ */ new Map();
      function clearColorModificationCache() {
        colorModificationCache.clear();
      }
      var rgbCacheKeys = ["r", "g", "b", "a"];
      var themeCacheKeys$1 = [
        "mode",
        "brightness",
        "contrast",
        "grayscale",
        "sepia",
        "darkSchemeBackgroundColor",
        "darkSchemeTextColor",
        "lightSchemeBackgroundColor",
        "lightSchemeTextColor"
      ];
      function getCacheId(rgb, theme) {
        var resultId = "";
        rgbCacheKeys.forEach(function(key) {
          resultId += "".concat(rgb[key], ";");
        });
        themeCacheKeys$1.forEach(function(key) {
          resultId += "".concat(theme[key], ";");
        });
        return resultId;
      }
      function modifyColorWithCache(rgb, theme, modifyHSL, poleColor, anotherPoleColor) {
        var fnCache;
        if (colorModificationCache.has(modifyHSL)) {
          fnCache = colorModificationCache.get(modifyHSL);
        } else {
          fnCache = /* @__PURE__ */ new Map();
          colorModificationCache.set(modifyHSL, fnCache);
        }
        var id = getCacheId(rgb, theme);
        if (fnCache.has(id)) {
          return fnCache.get(id);
        }
        var hsl = rgbToHSL(rgb);
        var pole = poleColor == null ? null : parseToHSLWithCache(poleColor);
        var anotherPole = anotherPoleColor == null ? null : parseToHSLWithCache(anotherPoleColor);
        var modified = modifyHSL(hsl, pole, anotherPole);
        var _a = hslToRGB(modified), r = _a.r, g = _a.g, b = _a.b, a = _a.a;
        var matrix = createFilterMatrix(theme);
        var _b = __read(applyColorMatrix([r, g, b], matrix), 3), rf = _b[0], gf = _b[1], bf = _b[2];
        var color = a === 1 ? rgbToHexString({ r: rf, g: gf, b: bf }) : rgbToString({ r: rf, g: gf, b: bf, a });
        fnCache.set(id, color);
        return color;
      }
      function noopHSL(hsl) {
        return hsl;
      }
      function modifyColor(rgb, theme) {
        return modifyColorWithCache(rgb, theme, noopHSL);
      }
      function modifyLightSchemeColor(rgb, theme) {
        var poleBg = getBgPole(theme);
        var poleFg = getFgPole(theme);
        return modifyColorWithCache(
          rgb,
          theme,
          modifyLightModeHSL,
          poleFg,
          poleBg
        );
      }
      function modifyLightModeHSL(_a, poleFg, poleBg) {
        var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
        var isDark = l < 0.5;
        var isNeutral;
        if (isDark) {
          isNeutral = l < 0.2 || s < 0.12;
        } else {
          var isBlue = h > 200 && h < 280;
          isNeutral = s < 0.24 || l > 0.8 && isBlue;
        }
        var hx = h;
        var sx = l;
        if (isNeutral) {
          if (isDark) {
            hx = poleFg.h;
            sx = poleFg.s;
          } else {
            hx = poleBg.h;
            sx = poleBg.s;
          }
        }
        var lx = scale(l, 0, 1, poleFg.l, poleBg.l);
        return { h: hx, s: sx, l: lx, a };
      }
      var MAX_BG_LIGHTNESS = 0.4;
      function modifyBgHSL(_a, pole) {
        var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
        var isDark = l < 0.5;
        var isBlue = h > 200 && h < 280;
        var isNeutral = s < 0.12 || l > 0.8 && isBlue;
        if (isDark) {
          var lx_1 = scale(l, 0, 0.5, 0, MAX_BG_LIGHTNESS);
          if (isNeutral) {
            var hx_1 = pole.h;
            var sx = pole.s;
            return { h: hx_1, s: sx, l: lx_1, a };
          }
          return { h, s, l: lx_1, a };
        }
        var lx = scale(l, 0.5, 1, MAX_BG_LIGHTNESS, pole.l);
        if (isNeutral) {
          var hx_2 = pole.h;
          var sx = pole.s;
          return { h: hx_2, s: sx, l: lx, a };
        }
        var hx = h;
        var isYellow = h > 60 && h < 180;
        if (isYellow) {
          var isCloserToGreen = h > 120;
          if (isCloserToGreen) {
            hx = scale(h, 120, 180, 135, 180);
          } else {
            hx = scale(h, 60, 120, 60, 105);
          }
        }
        if (hx > 40 && hx < 80) {
          lx *= 0.75;
        }
        return { h: hx, s, l: lx, a };
      }
      function modifyBackgroundColor(rgb, theme) {
        if (theme.mode === 0) {
          return modifyLightSchemeColor(rgb, theme);
        }
        var pole = getBgPole(theme);
        return modifyColorWithCache(
          rgb,
          __assign(__assign({}, theme), { mode: 0 }),
          modifyBgHSL,
          pole
        );
      }
      var MIN_FG_LIGHTNESS = 0.55;
      function modifyBlueFgHue(hue) {
        return scale(hue, 205, 245, 205, 220);
      }
      function modifyFgHSL(_a, pole) {
        var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
        var isLight = l > 0.5;
        var isNeutral = l < 0.2 || s < 0.24;
        var isBlue = !isNeutral && h > 205 && h < 245;
        if (isLight) {
          var lx_2 = scale(l, 0.5, 1, MIN_FG_LIGHTNESS, pole.l);
          if (isNeutral) {
            var hx_3 = pole.h;
            var sx = pole.s;
            return { h: hx_3, s: sx, l: lx_2, a };
          }
          var hx_4 = h;
          if (isBlue) {
            hx_4 = modifyBlueFgHue(h);
          }
          return { h: hx_4, s, l: lx_2, a };
        }
        if (isNeutral) {
          var hx_5 = pole.h;
          var sx = pole.s;
          var lx_3 = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);
          return { h: hx_5, s: sx, l: lx_3, a };
        }
        var hx = h;
        var lx;
        if (isBlue) {
          hx = modifyBlueFgHue(h);
          lx = scale(l, 0, 0.5, pole.l, Math.min(1, MIN_FG_LIGHTNESS + 0.05));
        } else {
          lx = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);
        }
        return { h: hx, s, l: lx, a };
      }
      function modifyForegroundColor(rgb, theme) {
        if (theme.mode === 0) {
          return modifyLightSchemeColor(rgb, theme);
        }
        var pole = getFgPole(theme);
        return modifyColorWithCache(
          rgb,
          __assign(__assign({}, theme), { mode: 0 }),
          modifyFgHSL,
          pole
        );
      }
      function modifyBorderHSL(_a, poleFg, poleBg) {
        var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
        var isDark = l < 0.5;
        var isNeutral = l < 0.2 || s < 0.24;
        var hx = h;
        var sx = s;
        if (isNeutral) {
          if (isDark) {
            hx = poleFg.h;
            sx = poleFg.s;
          } else {
            hx = poleBg.h;
            sx = poleBg.s;
          }
        }
        var lx = scale(l, 0, 1, 0.5, 0.2);
        return { h: hx, s: sx, l: lx, a };
      }
      function modifyBorderColor(rgb, theme) {
        if (theme.mode === 0) {
          return modifyLightSchemeColor(rgb, theme);
        }
        var poleFg = getFgPole(theme);
        var poleBg = getBgPole(theme);
        return modifyColorWithCache(
          rgb,
          __assign(__assign({}, theme), { mode: 0 }),
          modifyBorderHSL,
          poleFg,
          poleBg
        );
      }
      function modifyShadowColor(rgb, filter2) {
        return modifyBackgroundColor(rgb, filter2);
      }
      function modifyGradientColor(rgb, filter2) {
        return modifyBackgroundColor(rgb, filter2);
      }
      function createTextStyle(config) {
        var lines = [];
        lines.push(
          '*:not(pre, pre *, code, .far, .fa, .glyphicon, [class*="vjs-"], .fab, .fa-github, .fas, .material-icons, .icofont, .typcn, mu, [class*="mu-"], .glyphicon, .icon) {'
        );
        if (config.useFont && config.fontFamily) {
          lines.push(
            "  font-family: ".concat(config.fontFamily, " !important;")
          );
        }
        if (config.textStroke > 0) {
          lines.push(
            "  -webkit-text-stroke: ".concat(
              config.textStroke,
              "px !important;"
            )
          );
          lines.push(
            "  text-stroke: ".concat(config.textStroke, "px !important;")
          );
        }
        lines.push("}");
        return lines.join("\n");
      }
      var FilterMode;
      (function(FilterMode2) {
        FilterMode2[FilterMode2["light"] = 0] = "light";
        FilterMode2[FilterMode2["dark"] = 1] = "dark";
      })(FilterMode || (FilterMode = {}));
      function getCSSFilterValue(config) {
        var filters = [];
        if (config.mode === FilterMode.dark) {
          filters.push("invert(100%) hue-rotate(180deg)");
        }
        if (config.brightness !== 100) {
          filters.push("brightness(".concat(config.brightness, "%)"));
        }
        if (config.contrast !== 100) {
          filters.push("contrast(".concat(config.contrast, "%)"));
        }
        if (config.grayscale !== 0) {
          filters.push("grayscale(".concat(config.grayscale, "%)"));
        }
        if (config.sepia !== 0) {
          filters.push("sepia(".concat(config.sepia, "%)"));
        }
        if (filters.length === 0) {
          return null;
        }
        return filters.join(" ");
      }
      function toSVGMatrix(matrix) {
        return matrix.slice(0, 4).map(function(m) {
          return m.map(function(m2) {
            return m2.toFixed(3);
          }).join(" ");
        }).join(" ");
      }
      function getSVGFilterMatrixValue(config) {
        return toSVGMatrix(createFilterMatrix(config));
      }
      var counter = 0;
      var resolvers$1 = /* @__PURE__ */ new Map();
      var rejectors = /* @__PURE__ */ new Map();
      function bgFetch(request) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [
              2,
              new Promise(function(resolve, reject) {
                var id = ++counter;
                resolvers$1.set(id, resolve);
                rejectors.set(id, reject);
                chrome.runtime.sendMessage({
                  type: MessageType.CS_FETCH,
                  data: request,
                  id
                });
              })
            ];
          });
        });
      }
      chrome.runtime.onMessage.addListener(function(_a) {
        var type = _a.type, data = _a.data, error = _a.error, id = _a.id;
        if (type === MessageType.BG_FETCH_RESPONSE) {
          var resolve = resolvers$1.get(id);
          var reject = rejectors.get(id);
          resolvers$1.delete(id);
          rejectors.delete(id);
          if (error) {
            reject && reject(error);
          } else {
            resolve && resolve(data);
          }
        }
      });
      var AsyncQueue = function() {
        function AsyncQueue2() {
          this.queue = [];
          this.timerId = null;
          this.frameDuration = 1e3 / 60;
        }
        AsyncQueue2.prototype.addToQueue = function(entry) {
          this.queue.push(entry);
          this.startQueue();
        };
        AsyncQueue2.prototype.stopQueue = function() {
          if (this.timerId !== null) {
            cancelAnimationFrame(this.timerId);
            this.timerId = null;
          }
          this.queue = [];
        };
        AsyncQueue2.prototype.startQueue = function() {
          var _this = this;
          if (this.timerId) {
            return;
          }
          this.timerId = requestAnimationFrame(function() {
            _this.timerId = null;
            var start = Date.now();
            var cb;
            while (cb = _this.queue.shift()) {
              cb();
              if (Date.now() - start >= _this.frameDuration) {
                _this.startQueue();
                break;
              }
            }
          });
        };
        return AsyncQueue2;
      }();
      var imageManager = new AsyncQueue();
      function getImageDetails(url) {
        return __awaiter(this, void 0, void 0, function() {
          var _this = this;
          return __generator(this, function(_a) {
            return [
              2,
              new Promise(function(resolve, reject) {
                return __awaiter(_this, void 0, void 0, function() {
                  var dataURL, error_1, image_1, error_2;
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        if (!url.startsWith("data:"))
                          return [3, 1];
                        dataURL = url;
                        return [3, 4];
                      case 1:
                        _a2.trys.push([1, 3, , 4]);
                        return [4, getImageDataURL(url)];
                      case 2:
                        dataURL = _a2.sent();
                        return [3, 4];
                      case 3:
                        error_1 = _a2.sent();
                        reject(error_1);
                        return [2];
                      case 4:
                        _a2.trys.push([4, 6, , 7]);
                        return [4, urlToImage(dataURL)];
                      case 5:
                        image_1 = _a2.sent();
                        imageManager.addToQueue(function() {
                          resolve(
                            __assign(
                              {
                                src: url,
                                dataURL,
                                width: image_1.naturalWidth,
                                height: image_1.naturalHeight
                              },
                              analyzeImage(image_1)
                            )
                          );
                        });
                        return [3, 7];
                      case 6:
                        error_2 = _a2.sent();
                        reject(error_2);
                        return [3, 7];
                      case 7:
                        return [2];
                    }
                  });
                });
              })
            ];
          });
        });
      }
      function getImageDataURL(url) {
        return __awaiter(this, void 0, void 0, function() {
          var parsedURL;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                parsedURL = new URL(url);
                if (!(parsedURL.origin === location.origin))
                  return [3, 2];
                return [4, loadAsDataURL(url)];
              case 1:
                return [2, _a.sent()];
              case 2:
                return [
                  4,
                  bgFetch({ url, responseType: "data-url" })
                ];
              case 3:
                return [2, _a.sent()];
            }
          });
        });
      }
      function urlToImage(url) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [
              2,
              new Promise(function(resolve, reject) {
                var image = new Image();
                image.onload = function() {
                  return resolve(image);
                };
                image.onerror = function() {
                  return reject("Unable to load image ".concat(url));
                };
                image.src = url;
              })
            ];
          });
        });
      }
      var MAX_ANALIZE_PIXELS_COUNT = 32 * 32;
      var canvas;
      var context;
      function createCanvas() {
        var maxWidth = MAX_ANALIZE_PIXELS_COUNT;
        var maxHeight = MAX_ANALIZE_PIXELS_COUNT;
        canvas = document.createElement("canvas");
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        context = canvas.getContext("2d");
        context.imageSmoothingEnabled = false;
      }
      function removeCanvas() {
        canvas = null;
        context = null;
      }
      var MAX_IMAGE_SIZE = 5 * 1024 * 1024;
      function analyzeImage(image) {
        if (!canvas) {
          createCanvas();
        }
        var naturalWidth = image.naturalWidth, naturalHeight = image.naturalHeight;
        if (naturalHeight === 0 || naturalWidth === 0) {
          logWarn("logWarn(Image is empty ".concat(image.currentSrc, ")"));
          return null;
        }
        var size = naturalWidth * naturalHeight * 4;
        if (size > MAX_IMAGE_SIZE) {
          return {
            isDark: false,
            isLight: false,
            isTransparent: false,
            isLarge: false,
            isTooLarge: true
          };
        }
        var naturalPixelsCount = naturalWidth * naturalHeight;
        var k = Math.min(
          1,
          Math.sqrt(MAX_ANALIZE_PIXELS_COUNT / naturalPixelsCount)
        );
        var width = Math.ceil(naturalWidth * k);
        var height = Math.ceil(naturalHeight * k);
        context.clearRect(0, 0, width, height);
        context.drawImage(
          image,
          0,
          0,
          naturalWidth,
          naturalHeight,
          0,
          0,
          width,
          height
        );
        var imageData = context.getImageData(0, 0, width, height);
        var d = imageData.data;
        var TRANSPARENT_ALPHA_THRESHOLD = 0.05;
        var DARK_LIGHTNESS_THRESHOLD = 0.4;
        var LIGHT_LIGHTNESS_THRESHOLD = 0.7;
        var transparentPixelsCount = 0;
        var darkPixelsCount = 0;
        var lightPixelsCount = 0;
        var i, x, y;
        var r, g, b, a;
        var l;
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            i = 4 * (y * width + x);
            r = d[i + 0];
            g = d[i + 1];
            b = d[i + 2];
            a = d[i + 3];
            if (a / 255 < TRANSPARENT_ALPHA_THRESHOLD) {
              transparentPixelsCount++;
            } else {
              l = getSRGBLightness(r, g, b);
              if (l < DARK_LIGHTNESS_THRESHOLD) {
                darkPixelsCount++;
              }
              if (l > LIGHT_LIGHTNESS_THRESHOLD) {
                lightPixelsCount++;
              }
            }
          }
        }
        var totalPixelsCount = width * height;
        var opaquePixelsCount = totalPixelsCount - transparentPixelsCount;
        var DARK_IMAGE_THRESHOLD = 0.7;
        var LIGHT_IMAGE_THRESHOLD = 0.7;
        var TRANSPARENT_IMAGE_THRESHOLD = 0.1;
        var LARGE_IMAGE_PIXELS_COUNT = 800 * 600;
        return {
          isDark: darkPixelsCount / opaquePixelsCount >= DARK_IMAGE_THRESHOLD,
          isLight: lightPixelsCount / opaquePixelsCount >= LIGHT_IMAGE_THRESHOLD,
          isTransparent: transparentPixelsCount / totalPixelsCount >= TRANSPARENT_IMAGE_THRESHOLD,
          isLarge: naturalPixelsCount >= LARGE_IMAGE_PIXELS_COUNT,
          isTooLarge: false
        };
      }
      function getFilteredImageDataURL(_a, theme) {
        var dataURL = _a.dataURL, width = _a.width, height = _a.height;
        var matrix = getSVGFilterMatrixValue(theme);
        var svg = [
          '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="'.concat(width, '" height="').concat(height, '">'),
          "<defs>",
          '<filter id="darkreader-image-filter">',
          '<feColorMatrix type="matrix" values="'.concat(matrix, '" />'),
          "</filter>",
          "</defs>",
          '<image width="'.concat(width, '" height="').concat(
            height,
            '" filter="url(#darkreader-image-filter)" xlink:href="'
          ).concat(dataURL, '" />'),
          "</svg>"
        ].join("");
        return "data:image/svg+xml;base64,".concat(btoa(svg));
      }
      function cleanImageProcessingCache() {
        imageManager && imageManager.stopQueue();
        removeCanvas();
      }
      var gradientLength = "gradient".length;
      var conicGradient = "conic-";
      var conicGradientLength = conicGradient.length;
      var radialGradient = "radial-";
      var linearGradient = "linear-";
      function parseGradient(value) {
        var result = [];
        var index = 0;
        var startIndex = conicGradient.length;
        var _loop_1 = function() {
          var typeGradient;
          [linearGradient, radialGradient, conicGradient].find(function(possibleType) {
            if (index - possibleType.length >= 0) {
              var possibleGradient = value.substring(
                index - possibleType.length,
                index
              );
              if (possibleGradient === possibleType) {
                if (value.slice(
                  index - possibleType.length - 10,
                  index - possibleType.length - 1
                ) === "repeating") {
                  typeGradient = "repeating-".concat(
                    possibleType,
                    "gradient"
                  );
                  return true;
                }
                if (value.slice(
                  index - possibleType.length - 8,
                  index - possibleType.length - 1
                ) === "-webkit") {
                  typeGradient = "-webkit-".concat(
                    possibleType,
                    "gradient"
                  );
                  return true;
                }
                typeGradient = "".concat(possibleType, "gradient");
                return true;
              }
            }
          });
          if (!typeGradient) {
            return "break";
          }
          var _a = getParenthesesRange(value, index + gradientLength), start = _a.start, end = _a.end;
          var match = value.substring(start + 1, end - 1);
          startIndex = end + 1 + conicGradientLength;
          result.push({
            typeGradient,
            match,
            offset: typeGradient.length + 2,
            index: index - typeGradient.length + gradientLength,
            hasComma: true
          });
        };
        while ((index = value.indexOf("gradient", startIndex)) !== -1) {
          var state_1 = _loop_1();
          if (state_1 === "break")
            break;
        }
        if (result.length) {
          result[result.length - 1].hasComma = false;
        }
        return result;
      }
      function getPriority(ruleStyle, property) {
        return Boolean(ruleStyle && ruleStyle.getPropertyPriority(property));
      }
      function getModifiableCSSDeclaration(property, value, rule, variablesStore2, ignoreImageSelectors, isCancelled) {
        if (property.startsWith("--")) {
          var modifier = getVariableModifier(
            variablesStore2,
            property,
            value,
            rule,
            ignoreImageSelectors,
            isCancelled
          );
          if (modifier) {
            return {
              property,
              value: modifier,
              important: getPriority(rule.style, property),
              sourceValue: value
            };
          }
        } else if (value.includes("var(")) {
          var modifier = getVariableDependantModifier(
            variablesStore2,
            property,
            value
          );
          if (modifier) {
            return {
              property,
              value: modifier,
              important: getPriority(rule.style, property),
              sourceValue: value
            };
          }
        } else if (property === "color-scheme") {
          return null;
        } else if (property.includes("color") && property !== "-webkit-print-color-adjust" || property === "fill" || property === "stroke" || property === "stop-color") {
          var modifier = getColorModifier(property, value, rule);
          if (modifier) {
            return {
              property,
              value: modifier,
              important: getPriority(rule.style, property),
              sourceValue: value
            };
          }
        } else if (property === "background-image" || property === "list-style-image") {
          var modifier = getBgImageModifier(
            value,
            rule,
            ignoreImageSelectors,
            isCancelled
          );
          if (modifier) {
            return {
              property,
              value: modifier,
              important: getPriority(rule.style, property),
              sourceValue: value
            };
          }
        } else if (property.includes("shadow")) {
          var modifier = getShadowModifier(value);
          if (modifier) {
            return {
              property,
              value: modifier,
              important: getPriority(rule.style, property),
              sourceValue: value
            };
          }
        }
        return null;
      }
      function joinSelectors() {
        var selectors = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          selectors[_i] = arguments[_i];
        }
        return selectors.filter(Boolean).join(", ");
      }
      function getModifiedUserAgentStyle(theme, isIFrame2, styleSystemControls) {
        var lines = [];
        if (!isIFrame2) {
          lines.push("html {");
          lines.push(
            "    background-color: ".concat(
              modifyBackgroundColor({ r: 255, g: 255, b: 255 }, theme),
              " !important;"
            )
          );
          lines.push("}");
        }
        if (isCSSColorSchemePropSupported) {
          lines.push("html {");
          lines.push(
            "    color-scheme: ".concat(
              theme.mode === 1 ? "dark" : "dark light",
              " !important;"
            )
          );
          lines.push("}");
        }
        var bgSelectors = joinSelectors(
          isIFrame2 ? "" : "html, body",
          styleSystemControls ? "input, textarea, select, button, dialog" : ""
        );
        if (bgSelectors) {
          lines.push("".concat(bgSelectors, " {"));
          lines.push(
            "    background-color: ".concat(
              modifyBackgroundColor({ r: 255, g: 255, b: 255 }, theme),
              ";"
            )
          );
          lines.push("}");
        }
        lines.push(
          "".concat(
            joinSelectors(
              "html, body",
              styleSystemControls ? "input, textarea, select, button" : ""
            ),
            " {"
          )
        );
        lines.push(
          "    border-color: ".concat(
            modifyBorderColor({ r: 76, g: 76, b: 76 }, theme),
            ";"
          )
        );
        lines.push(
          "    color: ".concat(
            modifyForegroundColor({ r: 0, g: 0, b: 0 }, theme),
            ";"
          )
        );
        lines.push("}");
        lines.push("a {");
        lines.push(
          "    color: ".concat(
            modifyForegroundColor({ r: 0, g: 64, b: 255 }, theme),
            ";"
          )
        );
        lines.push("}");
        lines.push("table {");
        lines.push(
          "    border-color: ".concat(
            modifyBorderColor({ r: 128, g: 128, b: 128 }, theme),
            ";"
          )
        );
        lines.push("}");
        lines.push("::placeholder {");
        lines.push(
          "    color: ".concat(
            modifyForegroundColor({ r: 169, g: 169, b: 169 }, theme),
            ";"
          )
        );
        lines.push("}");
        lines.push("input:-webkit-autofill,");
        lines.push("textarea:-webkit-autofill,");
        lines.push("select:-webkit-autofill {");
        lines.push(
          "    background-color: ".concat(
            modifyBackgroundColor({ r: 250, g: 255, b: 189 }, theme),
            " !important;"
          )
        );
        lines.push(
          "    color: ".concat(
            modifyForegroundColor({ r: 0, g: 0, b: 0 }, theme),
            " !important;"
          )
        );
        lines.push("}");
        if (theme.scrollbarColor) {
          lines.push(getModifiedScrollbarStyle(theme));
        }
        if (theme.selectionColor) {
          lines.push(getModifiedSelectionStyle(theme));
        }
        return lines.join("\n");
      }
      function getSelectionColor(theme) {
        var backgroundColorSelection;
        var foregroundColorSelection;
        if (theme.selectionColor === "auto") {
          backgroundColorSelection = modifyBackgroundColor(
            { r: 0, g: 96, b: 212 },
            __assign(__assign({}, theme), { grayscale: 0 })
          );
          foregroundColorSelection = modifyForegroundColor(
            { r: 255, g: 255, b: 255 },
            __assign(__assign({}, theme), { grayscale: 0 })
          );
        } else {
          var rgb = parseColorWithCache(theme.selectionColor);
          var hsl = rgbToHSL(rgb);
          backgroundColorSelection = theme.selectionColor;
          if (hsl.l < 0.5) {
            foregroundColorSelection = "#FFF";
          } else {
            foregroundColorSelection = "#000";
          }
        }
        return {
          backgroundColorSelection,
          foregroundColorSelection
        };
      }
      function getModifiedSelectionStyle(theme) {
        var lines = [];
        var modifiedSelectionColor = getSelectionColor(theme);
        var backgroundColorSelection = modifiedSelectionColor.backgroundColorSelection;
        var foregroundColorSelection = modifiedSelectionColor.foregroundColorSelection;
        ["::selection", "::-moz-selection"].forEach(function(selection) {
          lines.push("".concat(selection, " {"));
          lines.push(
            "    background-color: ".concat(
              backgroundColorSelection,
              " !important;"
            )
          );
          lines.push(
            "    color: ".concat(foregroundColorSelection, " !important;")
          );
          lines.push("}");
        });
        return lines.join("\n");
      }
      function getModifiedScrollbarStyle(theme) {
        var lines = [];
        var colorTrack;
        var colorIcons;
        var colorThumb;
        var colorThumbHover;
        var colorThumbActive;
        var colorCorner;
        if (theme.scrollbarColor === "auto") {
          colorTrack = modifyBackgroundColor({ r: 241, g: 241, b: 241 }, theme);
          colorIcons = modifyForegroundColor({ r: 96, g: 96, b: 96 }, theme);
          colorThumb = modifyBackgroundColor({ r: 176, g: 176, b: 176 }, theme);
          colorThumbHover = modifyBackgroundColor(
            { r: 144, g: 144, b: 144 },
            theme
          );
          colorThumbActive = modifyBackgroundColor(
            { r: 96, g: 96, b: 96 },
            theme
          );
          colorCorner = modifyBackgroundColor(
            { r: 255, g: 255, b: 255 },
            theme
          );
        } else {
          var rgb = parseColorWithCache(theme.scrollbarColor);
          var hsl_1 = rgbToHSL(rgb);
          var isLight = hsl_1.l > 0.5;
          var lighten = function(lighter) {
            return __assign(__assign({}, hsl_1), {
              l: clamp(hsl_1.l + lighter, 0, 1)
            });
          };
          var darken = function(darker) {
            return __assign(__assign({}, hsl_1), {
              l: clamp(hsl_1.l - darker, 0, 1)
            });
          };
          colorTrack = hslToString(darken(0.4));
          colorIcons = hslToString(isLight ? darken(0.4) : lighten(0.4));
          colorThumb = hslToString(hsl_1);
          colorThumbHover = hslToString(lighten(0.1));
          colorThumbActive = hslToString(lighten(0.2));
        }
        lines.push("::-webkit-scrollbar {");
        lines.push("    background-color: ".concat(colorTrack, ";"));
        lines.push("    color: ".concat(colorIcons, ";"));
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb {");
        lines.push("    background-color: ".concat(colorThumb, ";"));
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb:hover {");
        lines.push("    background-color: ".concat(colorThumbHover, ";"));
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb:active {");
        lines.push("    background-color: ".concat(colorThumbActive, ";"));
        lines.push("}");
        lines.push("::-webkit-scrollbar-corner {");
        lines.push("    background-color: ".concat(colorCorner, ";"));
        lines.push("}");
        if (isFirefox) {
          lines.push("* {");
          lines.push(
            "    scrollbar-color: ".concat(colorThumb, " ").concat(colorTrack, ";")
          );
          lines.push("}");
        }
        return lines.join("\n");
      }
      function getModifiedFallbackStyle(filter2, _a) {
        var strict = _a.strict;
        var lines = [];
        var isMicrosoft = ["microsoft.com", "docs.microsoft.com"].includes(
          location.hostname
        );
        lines.push(
          "html, body, ".concat(
            strict ? "body :not(iframe)".concat(
              isMicrosoft ? ':not(div[style^="position:absolute;top:0;left:-"]' : ""
            ) : "body > :not(iframe)",
            " {"
          )
        );
        lines.push(
          "    background-color: ".concat(
            modifyBackgroundColor({ r: 255, g: 255, b: 255 }, filter2),
            " !important;"
          )
        );
        lines.push(
          "    border-color: ".concat(
            modifyBorderColor({ r: 64, g: 64, b: 64 }, filter2),
            " !important;"
          )
        );
        lines.push(
          "    color: ".concat(
            modifyForegroundColor({ r: 0, g: 0, b: 0 }, filter2),
            " !important;"
          )
        );
        lines.push("}");
        return lines.join("\n");
      }
      var unparsableColors = /* @__PURE__ */ new Set([
        "inherit",
        "transparent",
        "initial",
        "currentcolor",
        "none",
        "unset"
      ]);
      function getColorModifier(prop, value, rule) {
        if (unparsableColors.has(value.toLowerCase())) {
          return value;
        }
        var rgb = parseColorWithCache(value);
        if (!rgb) {
          return null;
        }
        if (prop.includes("background")) {
          if (rule.style.webkitMaskImage && rule.style.webkitMaskImage !== "none" || rule.style.webkitMask && !rule.style.webkitMask.startsWith("none") || rule.style.mask && rule.style.mask !== "none" || rule.style.getPropertyValue("mask-image") && rule.style.getPropertyValue("mask-image") !== "none") {
            return function(filter2) {
              return modifyForegroundColor(rgb, filter2);
            };
          }
          return function(filter2) {
            return modifyBackgroundColor(rgb, filter2);
          };
        }
        if (prop.includes("border") || prop.includes("outline")) {
          return function(filter2) {
            return modifyBorderColor(rgb, filter2);
          };
        }
        return function(filter2) {
          return modifyForegroundColor(rgb, filter2);
        };
      }
      var imageDetailsCache = /* @__PURE__ */ new Map();
      var awaitingForImageLoading = /* @__PURE__ */ new Map();
      function shouldIgnoreImage(selectorText, selectors) {
        if (!selectorText || selectors.length === 0) {
          return false;
        }
        if (selectors.some(function(s) {
          return s === "*";
        })) {
          return true;
        }
        var ruleSelectors = selectorText.split(/,\s*/g);
        var _loop_1 = function(i2) {
          var ignoredSelector = selectors[i2];
          if (ruleSelectors.some(function(s) {
            return s === ignoredSelector;
          })) {
            return { value: true };
          }
        };
        for (var i = 0; i < selectors.length; i++) {
          var state_1 = _loop_1(i);
          if (typeof state_1 === "object")
            return state_1.value;
        }
        return false;
      }
      function getBgImageModifier(value, rule, ignoreImageSelectors, isCancelled) {
        var _this = this;
        try {
          var gradients = parseGradient(value);
          var urls = getMatches(cssURLRegex, value);
          if (urls.length === 0 && gradients.length === 0) {
            return value;
          }
          var getIndices = function(matches) {
            var index = 0;
            return matches.map(function(match) {
              var valueIndex = value.indexOf(match, index);
              index = valueIndex + match.length;
              return { match, index: valueIndex };
            });
          };
          var matches_1 = gradients.map(function(i) {
            return __assign({ type: "gradient" }, i);
          }).concat(
            getIndices(urls).map(function(i) {
              return __assign({ type: "url", offset: 0 }, i);
            })
          ).sort(function(a, b) {
            return a.index > b.index ? 1 : -1;
          });
          var getGradientModifier_1 = function(gradient) {
            var typeGradient = gradient.typeGradient, match = gradient.match, hasComma = gradient.hasComma;
            var partsRegex = /([^\(\),]+(\([^\(\)]*(\([^\(\)]*\)*[^\(\)]*)?\))?([^\(\), ]|( (?!calc)))*),?/g;
            var colorStopRegex = /^(from|color-stop|to)\(([^\(\)]*?,\s*)?(.*?)\)$/;
            var parts = getMatches(partsRegex, match, 1).map(function(part) {
              part = part.trim();
              var rgb = parseColorWithCache(part);
              if (rgb) {
                return function(filter2) {
                  return modifyGradientColor(rgb, filter2);
                };
              }
              var space = part.lastIndexOf(" ");
              rgb = parseColorWithCache(part.substring(0, space));
              if (rgb) {
                return function(filter2) {
                  return "".concat(modifyGradientColor(rgb, filter2), " ").concat(part.substring(space + 1));
                };
              }
              var colorStopMatch = part.match(colorStopRegex);
              if (colorStopMatch) {
                rgb = parseColorWithCache(colorStopMatch[3]);
                if (rgb) {
                  return function(filter2) {
                    return "".concat(colorStopMatch[1], "(").concat(
                      colorStopMatch[2] ? "".concat(colorStopMatch[2], ", ") : ""
                    ).concat(
                      modifyGradientColor(rgb, filter2),
                      ")"
                    );
                  };
                }
              }
              return function() {
                return part;
              };
            });
            return function(filter2) {
              return "".concat(typeGradient, "(").concat(
                parts.map(function(modify) {
                  return modify(filter2);
                }).join(", "),
                ")"
              ).concat(hasComma ? ", " : "");
            };
          };
          var getURLModifier_1 = function(urlValue) {
            var _a;
            if (shouldIgnoreImage(rule.selectorText, ignoreImageSelectors)) {
              return null;
            }
            var url = getCSSURLValue(urlValue);
            var isURLEmpty = url.length === 0;
            var parentStyleSheet = rule.parentStyleSheet;
            var baseURL = parentStyleSheet && parentStyleSheet.href ? getCSSBaseBath(parentStyleSheet.href) : ((_a = parentStyleSheet.ownerNode) === null || _a === void 0 ? void 0 : _a.baseURI) || location.origin;
            url = getAbsoluteURL(baseURL, url);
            var absoluteValue = 'url("'.concat(url, '")');
            return function(filter2) {
              return __awaiter(_this, void 0, void 0, function() {
                var imageDetails, awaiters_1, err_1, bgImageValue;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (isURLEmpty) {
                        return [2, "url('')"];
                      }
                      if (!imageDetailsCache.has(url))
                        return [3, 1];
                      imageDetails = imageDetailsCache.get(url);
                      return [3, 7];
                    case 1:
                      _a2.trys.push([1, 6, , 7]);
                      if (!awaitingForImageLoading.has(url))
                        return [3, 3];
                      awaiters_1 = awaitingForImageLoading.get(url);
                      return [
                        4,
                        new Promise(function(resolve) {
                          return awaiters_1.push(resolve);
                        })
                      ];
                    case 2:
                      imageDetails = _a2.sent();
                      if (!imageDetails) {
                        return [2, null];
                      }
                      return [3, 5];
                    case 3:
                      awaitingForImageLoading.set(url, []);
                      return [4, getImageDetails(url)];
                    case 4:
                      imageDetails = _a2.sent();
                      imageDetailsCache.set(url, imageDetails);
                      awaitingForImageLoading.get(url).forEach(function(resolve) {
                        return resolve(imageDetails);
                      });
                      awaitingForImageLoading.delete(url);
                      _a2.label = 5;
                    case 5:
                      if (isCancelled()) {
                        return [2, null];
                      }
                      return [3, 7];
                    case 6:
                      err_1 = _a2.sent();
                      logWarn(err_1);
                      if (awaitingForImageLoading.has(url)) {
                        awaitingForImageLoading.get(url).forEach(function(resolve) {
                          return resolve(null);
                        });
                        awaitingForImageLoading.delete(url);
                      }
                      return [2, absoluteValue];
                    case 7:
                      bgImageValue = getBgImageValue_1(
                        imageDetails,
                        filter2
                      ) || absoluteValue;
                      return [2, bgImageValue];
                  }
                });
              });
            };
          };
          var getBgImageValue_1 = function(imageDetails, filter2) {
            var isDark = imageDetails.isDark, isLight = imageDetails.isLight, isTransparent = imageDetails.isTransparent, isLarge = imageDetails.isLarge, isTooLarge = imageDetails.isTooLarge, width = imageDetails.width;
            var result;
            if (isTooLarge) {
              result = 'url("'.concat(imageDetails.src, '")');
            } else if (isDark && isTransparent && filter2.mode === 1 && !isLarge && width > 2) {
              logInfo("Inverting dark image ".concat(imageDetails.src));
              var inverted = getFilteredImageDataURL(
                imageDetails,
                __assign(__assign({}, filter2), {
                  sepia: clamp(filter2.sepia + 10, 0, 100)
                })
              );
              result = 'url("'.concat(inverted, '")');
            } else if (isLight && !isTransparent && filter2.mode === 1) {
              if (isLarge) {
                result = "none";
              } else {
                logInfo(
                  "Dimming light image ".concat(imageDetails.src)
                );
                var dimmed = getFilteredImageDataURL(
                  imageDetails,
                  filter2
                );
                result = 'url("'.concat(dimmed, '")');
              }
            } else if (filter2.mode === 0 && isLight && !isLarge) {
              logInfo(
                "Applying filter to image ".concat(imageDetails.src)
              );
              var filtered = getFilteredImageDataURL(
                imageDetails,
                __assign(__assign({}, filter2), {
                  brightness: clamp(filter2.brightness - 10, 5, 200),
                  sepia: clamp(filter2.sepia + 10, 0, 100)
                })
              );
              result = 'url("'.concat(filtered, '")');
            } else {
              result = null;
            }
            return result;
          };
          var modifiers_1 = [];
          var matchIndex_1 = 0;
          var prevHasComma_1 = false;
          matches_1.forEach(function(_a, i) {
            var type = _a.type, match = _a.match, index = _a.index, typeGradient = _a.typeGradient, hasComma = _a.hasComma, offset = _a.offset;
            var matchStart = index;
            var prefixStart = matchIndex_1;
            var matchEnd = matchStart + match.length + offset;
            matchIndex_1 = matchEnd;
            if (prefixStart !== matchStart) {
              if (prevHasComma_1) {
                modifiers_1.push(function() {
                  var betweenValue = value.substring(
                    prefixStart,
                    matchStart
                  );
                  if (betweenValue[0] === ",") {
                    betweenValue = betweenValue.substring(1);
                  }
                  return betweenValue;
                });
              } else {
                modifiers_1.push(function() {
                  return value.substring(prefixStart, matchStart);
                });
              }
            }
            prevHasComma_1 = hasComma || false;
            if (type === "url") {
              modifiers_1.push(getURLModifier_1(match));
            } else if (type === "gradient") {
              modifiers_1.push(
                getGradientModifier_1({
                  match,
                  index,
                  typeGradient,
                  hasComma,
                  offset
                })
              );
            }
            if (i === matches_1.length - 1) {
              modifiers_1.push(function() {
                return value.substring(matchEnd);
              });
            }
          });
          return function(filter2) {
            var results = modifiers_1.filter(Boolean).map(function(modify) {
              return modify(filter2);
            });
            if (results.some(function(r) {
              return r instanceof Promise;
            })) {
              return Promise.all(results).then(function(asyncResults) {
                return asyncResults.filter(Boolean).join("");
              });
            }
            var combinedResult = results.join("");
            if (combinedResult.endsWith(", initial")) {
              return combinedResult.slice(0, -9);
            }
            return combinedResult;
          };
        } catch (err) {
          return null;
        }
      }
      function getShadowModifierWithInfo(value) {
        try {
          var index_1 = 0;
          var colorMatches_1 = getMatches(
            /(^|\s)(?!calc)([a-z]+\(.+?\)|#[0-9a-f]+|[a-z]+)(.*?(inset|outset)?($|,))/gi,
            value,
            2
          );
          var notParsed_1 = 0;
          var modifiers_2 = colorMatches_1.map(function(match, i) {
            var prefixIndex = index_1;
            var matchIndex = value.indexOf(match, index_1);
            var matchEnd = matchIndex + match.length;
            index_1 = matchEnd;
            var rgb = parseColorWithCache(match);
            if (!rgb) {
              notParsed_1++;
              return function() {
                return value.substring(prefixIndex, matchEnd);
              };
            }
            return function(filter2) {
              return "".concat(value.substring(prefixIndex, matchIndex)).concat(modifyShadowColor(rgb, filter2)).concat(
                i === colorMatches_1.length - 1 ? value.substring(matchEnd) : ""
              );
            };
          });
          return function(filter2) {
            var modified = modifiers_2.map(function(modify) {
              return modify(filter2);
            }).join("");
            return {
              matchesLength: colorMatches_1.length,
              unparseableMatchesLength: notParsed_1,
              result: modified
            };
          };
        } catch (err) {
          return null;
        }
      }
      function getShadowModifier(value) {
        var shadowModifier = getShadowModifierWithInfo(value);
        if (!shadowModifier) {
          return null;
        }
        return function(theme) {
          return shadowModifier(theme).result;
        };
      }
      function getVariableModifier(variablesStore2, prop, value, rule, ignoredImgSelectors, isCancelled) {
        return variablesStore2.getModifierForVariable({
          varName: prop,
          sourceValue: value,
          rule,
          ignoredImgSelectors,
          isCancelled
        });
      }
      function getVariableDependantModifier(variablesStore2, prop, value) {
        return variablesStore2.getModifierForVarDependant(prop, value);
      }
      function cleanModificationCache() {
        clearColorModificationCache();
        imageDetailsCache.clear();
        cleanImageProcessingCache();
        awaitingForImageLoading.clear();
      }
      var VAR_TYPE_BGCOLOR = 1 << 0;
      var VAR_TYPE_TEXTCOLOR = 1 << 1;
      var VAR_TYPE_BORDERCOLOR = 1 << 2;
      var VAR_TYPE_BGIMG = 1 << 3;
      var VariablesStore = function() {
        function VariablesStore2() {
          this.varTypes = /* @__PURE__ */ new Map();
          this.rulesQueue = [];
          this.definedVars = /* @__PURE__ */ new Set();
          this.varRefs = /* @__PURE__ */ new Map();
          this.unknownColorVars = /* @__PURE__ */ new Set();
          this.unknownBgVars = /* @__PURE__ */ new Set();
          this.undefinedVars = /* @__PURE__ */ new Set();
          this.initialVarTypes = /* @__PURE__ */ new Map();
          this.changedTypeVars = /* @__PURE__ */ new Set();
          this.typeChangeSubscriptions = /* @__PURE__ */ new Map();
          this.unstableVarValues = /* @__PURE__ */ new Map();
        }
        VariablesStore2.prototype.clear = function() {
          this.varTypes.clear();
          this.rulesQueue.splice(0);
          this.definedVars.clear();
          this.varRefs.clear();
          this.unknownColorVars.clear();
          this.unknownBgVars.clear();
          this.undefinedVars.clear();
          this.initialVarTypes.clear();
          this.changedTypeVars.clear();
          this.typeChangeSubscriptions.clear();
          this.unstableVarValues.clear();
        };
        VariablesStore2.prototype.isVarType = function(varName, typeNum) {
          return this.varTypes.has(varName) && (this.varTypes.get(varName) & typeNum) > 0;
        };
        VariablesStore2.prototype.addRulesForMatching = function(rules) {
          this.rulesQueue.push(rules);
        };
        VariablesStore2.prototype.matchVariablesAndDependants = function() {
          var _this = this;
          this.changedTypeVars.clear();
          this.initialVarTypes = new Map(this.varTypes);
          this.collectRootVariables();
          this.collectVariablesAndVarDep(this.rulesQueue);
          this.rulesQueue.splice(0);
          this.collectRootVarDependants();
          this.varRefs.forEach(function(refs, v) {
            refs.forEach(function(r) {
              if (_this.varTypes.has(v)) {
                _this.resolveVariableType(r, _this.varTypes.get(v));
              }
            });
          });
          this.unknownColorVars.forEach(function(v) {
            if (_this.unknownBgVars.has(v)) {
              _this.unknownColorVars.delete(v);
              _this.unknownBgVars.delete(v);
              _this.resolveVariableType(v, VAR_TYPE_BGCOLOR);
            } else if (_this.isVarType(
              v,
              VAR_TYPE_BGCOLOR | VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR
            )) {
              _this.unknownColorVars.delete(v);
            } else {
              _this.undefinedVars.add(v);
            }
          });
          this.unknownBgVars.forEach(function(v) {
            var hasColor = _this.findVarRef(v, function(ref) {
              return _this.unknownColorVars.has(ref) || _this.isVarType(
                ref,
                VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR
              );
            }) != null;
            if (hasColor) {
              _this.itarateVarRefs(v, function(ref) {
                _this.resolveVariableType(ref, VAR_TYPE_BGCOLOR);
              });
            } else if (_this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_BGIMG)) {
              _this.unknownBgVars.delete(v);
            } else {
              _this.undefinedVars.add(v);
            }
          });
          this.changedTypeVars.forEach(function(varName) {
            if (_this.typeChangeSubscriptions.has(varName)) {
              _this.typeChangeSubscriptions.get(varName).forEach(function(callback) {
                callback();
              });
            }
          });
          this.changedTypeVars.clear();
        };
        VariablesStore2.prototype.getModifierForVariable = function(options) {
          var _this = this;
          return function(theme) {
            var varName = options.varName, sourceValue = options.sourceValue, rule = options.rule, ignoredImgSelectors = options.ignoredImgSelectors, isCancelled = options.isCancelled;
            var getDeclarations = function() {
              var declarations = [];
              var addModifiedValue = function(typeNum, varNameWrapper, colorModifier) {
                if (!_this.isVarType(varName, typeNum)) {
                  return;
                }
                var property2 = varNameWrapper(varName);
                var modifiedValue2;
                if (isVarDependant(sourceValue)) {
                  if (isConstructedColorVar(sourceValue)) {
                    var value = insertVarValues(
                      sourceValue,
                      _this.unstableVarValues
                    );
                    if (!value) {
                      value = typeNum === VAR_TYPE_BGCOLOR ? "#ffffff" : "#000000";
                    }
                    modifiedValue2 = colorModifier(value, theme);
                  } else {
                    modifiedValue2 = replaceCSSVariablesNames(
                      sourceValue,
                      function(v) {
                        return varNameWrapper(v);
                      },
                      function(fallback) {
                        return colorModifier(fallback, theme);
                      }
                    );
                  }
                } else {
                  modifiedValue2 = colorModifier(sourceValue, theme);
                }
                declarations.push({
                  property: property2,
                  value: modifiedValue2
                });
              };
              addModifiedValue(
                VAR_TYPE_BGCOLOR,
                wrapBgColorVariableName,
                tryModifyBgColor
              );
              addModifiedValue(
                VAR_TYPE_TEXTCOLOR,
                wrapTextColorVariableName,
                tryModifyTextColor
              );
              addModifiedValue(
                VAR_TYPE_BORDERCOLOR,
                wrapBorderColorVariableName,
                tryModifyBorderColor
              );
              if (_this.isVarType(varName, VAR_TYPE_BGIMG)) {
                var property = wrapBgImgVariableName(varName);
                var modifiedValue = sourceValue;
                if (isVarDependant(sourceValue)) {
                  modifiedValue = replaceCSSVariablesNames(
                    sourceValue,
                    function(v) {
                      return wrapBgColorVariableName(v);
                    },
                    function(fallback) {
                      return tryModifyBgColor(fallback, theme);
                    }
                  );
                }
                var bgModifier = getBgImageModifier(
                  modifiedValue,
                  rule,
                  ignoredImgSelectors,
                  isCancelled
                );
                modifiedValue = typeof bgModifier === "function" ? bgModifier(theme) : bgModifier;
                declarations.push({
                  property,
                  value: modifiedValue
                });
              }
              return declarations;
            };
            var callbacks = /* @__PURE__ */ new Set();
            var addListener = function(onTypeChange) {
              var callback = function() {
                var decs = getDeclarations();
                onTypeChange(decs);
              };
              callbacks.add(callback);
              _this.subscribeForVarTypeChange(varName, callback);
            };
            var removeListeners = function() {
              callbacks.forEach(function(callback) {
                _this.unsubscribeFromVariableTypeChanges(
                  varName,
                  callback
                );
              });
            };
            return {
              declarations: getDeclarations(),
              onTypeChange: {
                addListener,
                removeListeners
              }
            };
          };
        };
        VariablesStore2.prototype.getModifierForVarDependant = function(property, sourceValue) {
          var _this = this;
          if (sourceValue.match(/^\s*(rgb|hsl)a?\(/)) {
            var isBg_1 = property.startsWith("background");
            var isText_1 = isTextColorProperty(property);
            return function(theme) {
              var value = insertVarValues(
                sourceValue,
                _this.unstableVarValues
              );
              if (!value) {
                value = isBg_1 ? "#ffffff" : "#000000";
              }
              var modifier = isBg_1 ? tryModifyBgColor : isText_1 ? tryModifyTextColor : tryModifyBorderColor;
              return modifier(value, theme);
            };
          }
          if (property === "background-color") {
            return function(theme) {
              return replaceCSSVariablesNames(
                sourceValue,
                function(v) {
                  return wrapBgColorVariableName(v);
                },
                function(fallback) {
                  return tryModifyBgColor(fallback, theme);
                }
              );
            };
          }
          if (isTextColorProperty(property)) {
            return function(theme) {
              return replaceCSSVariablesNames(
                sourceValue,
                function(v) {
                  return wrapTextColorVariableName(v);
                },
                function(fallback) {
                  return tryModifyTextColor(fallback, theme);
                }
              );
            };
          }
          if (property === "background" || property === "background-image" || property === "box-shadow") {
            return function(theme) {
              var unknownVars = /* @__PURE__ */ new Set();
              var modify = function() {
                var variableReplaced = replaceCSSVariablesNames(
                  sourceValue,
                  function(v) {
                    if (_this.isVarType(v, VAR_TYPE_BGCOLOR)) {
                      return wrapBgColorVariableName(v);
                    }
                    if (_this.isVarType(v, VAR_TYPE_BGIMG)) {
                      return wrapBgImgVariableName(v);
                    }
                    unknownVars.add(v);
                    return v;
                  },
                  function(fallback) {
                    return tryModifyBgColor(fallback, theme);
                  }
                );
                if (property === "box-shadow") {
                  var shadowModifier = getShadowModifierWithInfo(variableReplaced);
                  var modifiedShadow = shadowModifier(theme);
                  if (modifiedShadow.unparseableMatchesLength !== modifiedShadow.matchesLength) {
                    return modifiedShadow.result;
                  }
                }
                return variableReplaced;
              };
              var modified = modify();
              if (unknownVars.size > 0) {
                return new Promise(function(resolve) {
                  var firstUnknownVar = unknownVars.values().next().value;
                  var callback = function() {
                    _this.unsubscribeFromVariableTypeChanges(
                      firstUnknownVar,
                      callback
                    );
                    var newValue = modify();
                    resolve(newValue);
                  };
                  _this.subscribeForVarTypeChange(
                    firstUnknownVar,
                    callback
                  );
                });
              }
              return modified;
            };
          }
          if (property.startsWith("border") || property.startsWith("outline")) {
            return function(theme) {
              return replaceCSSVariablesNames(
                sourceValue,
                function(v) {
                  return wrapBorderColorVariableName(v);
                },
                function(fallback) {
                  return tryModifyBorderColor(fallback, theme);
                }
              );
            };
          }
          return null;
        };
        VariablesStore2.prototype.subscribeForVarTypeChange = function(varName, callback) {
          if (!this.typeChangeSubscriptions.has(varName)) {
            this.typeChangeSubscriptions.set(varName, /* @__PURE__ */ new Set());
          }
          var rootStore = this.typeChangeSubscriptions.get(varName);
          if (!rootStore.has(callback)) {
            rootStore.add(callback);
          }
        };
        VariablesStore2.prototype.unsubscribeFromVariableTypeChanges = function(varName, callback) {
          if (this.typeChangeSubscriptions.has(varName)) {
            this.typeChangeSubscriptions.get(varName).delete(callback);
          }
        };
        VariablesStore2.prototype.collectVariablesAndVarDep = function(ruleList) {
          var _this = this;
          ruleList.forEach(function(rules) {
            iterateCSSRules(rules, function(rule) {
              rule.style && iterateCSSDeclarations(
                rule.style,
                function(property, value) {
                  if (isVariable(property)) {
                    _this.inspectVariable(property, value);
                  }
                  if (isVarDependant(value)) {
                    _this.inspectVarDependant(property, value);
                  }
                }
              );
            });
          });
        };
        VariablesStore2.prototype.collectRootVariables = function() {
          var _this = this;
          iterateCSSDeclarations(
            document.documentElement.style,
            function(property, value) {
              if (isVariable(property)) {
                _this.inspectVariable(property, value);
              }
            }
          );
        };
        VariablesStore2.prototype.inspectVariable = function(varName, value) {
          this.unstableVarValues.set(varName, value);
          if (isVarDependant(value) && isConstructedColorVar(value)) {
            this.unknownColorVars.add(varName);
            this.definedVars.add(varName);
          }
          if (this.definedVars.has(varName)) {
            return;
          }
          this.definedVars.add(varName);
          var color = parseColorWithCache(value);
          if (color) {
            this.unknownColorVars.add(varName);
          } else if (value.includes("url(") || value.includes("linear-gradient(") || value.includes("radial-gradient(")) {
            this.resolveVariableType(varName, VAR_TYPE_BGIMG);
          }
        };
        VariablesStore2.prototype.resolveVariableType = function(varName, typeNum) {
          var initialType = this.initialVarTypes.get(varName) || 0;
          var currentType = this.varTypes.get(varName) || 0;
          var newType = currentType | typeNum;
          this.varTypes.set(varName, newType);
          if (newType !== initialType || this.undefinedVars.has(varName)) {
            this.changedTypeVars.add(varName);
            this.undefinedVars.delete(varName);
          }
          this.unknownColorVars.delete(varName);
          this.unknownBgVars.delete(varName);
        };
        VariablesStore2.prototype.collectRootVarDependants = function() {
          var _this = this;
          iterateCSSDeclarations(
            document.documentElement.style,
            function(property, value) {
              if (isVarDependant(value)) {
                _this.inspectVarDependant(property, value);
              }
            }
          );
        };
        VariablesStore2.prototype.inspectVarDependant = function(property, value) {
          var _this = this;
          if (isVariable(property)) {
            this.iterateVarDeps(value, function(ref) {
              if (!_this.varRefs.has(property)) {
                _this.varRefs.set(property, /* @__PURE__ */ new Set());
              }
              _this.varRefs.get(property).add(ref);
            });
          } else if (property === "background-color" || property === "box-shadow") {
            this.iterateVarDeps(value, function(v) {
              return _this.resolveVariableType(v, VAR_TYPE_BGCOLOR);
            });
          } else if (isTextColorProperty(property)) {
            this.iterateVarDeps(value, function(v) {
              return _this.resolveVariableType(v, VAR_TYPE_TEXTCOLOR);
            });
          } else if (property.startsWith("border") || property.startsWith("outline")) {
            this.iterateVarDeps(value, function(v) {
              return _this.resolveVariableType(v, VAR_TYPE_BORDERCOLOR);
            });
          } else if (property === "background" || property === "background-image") {
            this.iterateVarDeps(value, function(v) {
              if (_this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_BGIMG)) {
                return;
              }
              var isBgColor = _this.findVarRef(v, function(ref) {
                return _this.unknownColorVars.has(ref) || _this.isVarType(
                  ref,
                  VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR
                );
              }) != null;
              _this.itarateVarRefs(v, function(ref) {
                if (isBgColor) {
                  _this.resolveVariableType(ref, VAR_TYPE_BGCOLOR);
                } else {
                  _this.unknownBgVars.add(ref);
                }
              });
            });
          }
        };
        VariablesStore2.prototype.iterateVarDeps = function(value, iterator) {
          var varDeps = /* @__PURE__ */ new Set();
          iterateVarDependencies(value, function(v) {
            return varDeps.add(v);
          });
          varDeps.forEach(function(v) {
            return iterator(v);
          });
        };
        VariablesStore2.prototype.findVarRef = function(varName, iterator, stack) {
          var e_1, _a;
          if (stack === void 0) {
            stack = /* @__PURE__ */ new Set();
          }
          if (stack.has(varName)) {
            return null;
          }
          stack.add(varName);
          var result = iterator(varName);
          if (result) {
            return varName;
          }
          var refs = this.varRefs.get(varName);
          if (!refs || refs.size === 0) {
            return null;
          }
          try {
            for (var refs_1 = __values(refs), refs_1_1 = refs_1.next(); !refs_1_1.done; refs_1_1 = refs_1.next()) {
              var ref = refs_1_1.value;
              var found = this.findVarRef(ref, iterator, stack);
              if (found) {
                return found;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (refs_1_1 && !refs_1_1.done && (_a = refs_1.return))
                _a.call(refs_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return null;
        };
        VariablesStore2.prototype.itarateVarRefs = function(varName, iterator) {
          this.findVarRef(varName, function(ref) {
            iterator(ref);
            return false;
          });
        };
        VariablesStore2.prototype.setOnRootVariableChange = function(callback) {
          this.onRootVariableDefined = callback;
        };
        VariablesStore2.prototype.putRootVars = function(styleElement, theme) {
          var e_2, _a;
          var _this = this;
          var sheet = styleElement.sheet;
          if (sheet.cssRules.length > 0) {
            sheet.deleteRule(0);
          }
          var declarations = /* @__PURE__ */ new Map();
          iterateCSSDeclarations(
            document.documentElement.style,
            function(property2, value2) {
              if (isVariable(property2)) {
                if (_this.isVarType(property2, VAR_TYPE_BGCOLOR)) {
                  declarations.set(
                    wrapBgColorVariableName(property2),
                    tryModifyBgColor(value2, theme)
                  );
                }
                if (_this.isVarType(property2, VAR_TYPE_TEXTCOLOR)) {
                  declarations.set(
                    wrapTextColorVariableName(property2),
                    tryModifyTextColor(value2, theme)
                  );
                }
                if (_this.isVarType(property2, VAR_TYPE_BORDERCOLOR)) {
                  declarations.set(
                    wrapBorderColorVariableName(property2),
                    tryModifyBorderColor(value2, theme)
                  );
                }
                _this.subscribeForVarTypeChange(
                  property2,
                  _this.onRootVariableDefined
                );
              }
            }
          );
          var cssLines = [];
          cssLines.push(":root {");
          try {
            for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
              var _b = __read(declarations_1_1.value, 2), property = _b[0], value = _b[1];
              cssLines.push(
                "    ".concat(property, ": ").concat(value, ";")
              );
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (declarations_1_1 && !declarations_1_1.done && (_a = declarations_1.return))
                _a.call(declarations_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          cssLines.push("}");
          var cssText = cssLines.join("\n");
          sheet.insertRule(cssText);
        };
        return VariablesStore2;
      }();
      var variablesStore = new VariablesStore();
      function getVariableRange(input, searchStart) {
        if (searchStart === void 0) {
          searchStart = 0;
        }
        var start = input.indexOf("var(", searchStart);
        if (start >= 0) {
          var range = getParenthesesRange(input, start + 3);
          if (range) {
            return { start, end: range.end };
          }
          return null;
        }
      }
      function getVariablesMatches(input) {
        var ranges = [];
        var i = 0;
        var range;
        while (range = getVariableRange(input, i)) {
          var start = range.start, end = range.end;
          ranges.push({
            start,
            end,
            value: input.substring(start, end)
          });
          i = range.end + 1;
        }
        return ranges;
      }
      function replaceVariablesMatches(input, replacer) {
        var matches = getVariablesMatches(input);
        var matchesCount = matches.length;
        if (matchesCount === 0) {
          return input;
        }
        var inputLength = input.length;
        var replacements = matches.map(function(m) {
          return replacer(m.value);
        });
        var parts = [];
        parts.push(input.substring(0, matches[0].start));
        for (var i = 0; i < matchesCount; i++) {
          parts.push(replacements[i]);
          var start = matches[i].end;
          var end = i < matchesCount - 1 ? matches[i + 1].start : inputLength;
          parts.push(input.substring(start, end));
        }
        return parts.join("");
      }
      function getVariableNameAndFallback(match) {
        var commaIndex = match.indexOf(",");
        var name;
        var fallback;
        if (commaIndex >= 0) {
          name = match.substring(4, commaIndex).trim();
          fallback = match.substring(commaIndex + 1, match.length - 1).trim();
        } else {
          name = match.substring(4, match.length - 1).trim();
          fallback = "";
        }
        return { name, fallback };
      }
      function replaceCSSVariablesNames(value, nameReplacer, fallbackReplacer) {
        var matchReplacer = function(match) {
          var _a = getVariableNameAndFallback(match), name = _a.name, fallback = _a.fallback;
          var newName = nameReplacer(name);
          if (!fallback) {
            return "var(".concat(newName, ")");
          }
          var newFallback;
          if (isVarDependant(fallback)) {
            newFallback = replaceCSSVariablesNames(
              fallback,
              nameReplacer,
              fallbackReplacer
            );
          } else if (fallbackReplacer) {
            newFallback = fallbackReplacer(fallback);
          } else {
            newFallback = fallback;
          }
          return "var(".concat(newName, ", ").concat(newFallback, ")");
        };
        return replaceVariablesMatches(value, matchReplacer);
      }
      function iterateVarDependencies(value, iterator) {
        replaceCSSVariablesNames(value, function(varName) {
          iterator(varName);
          return varName;
        });
      }
      function wrapBgColorVariableName(name) {
        return "--darkreader-bg".concat(name);
      }
      function wrapTextColorVariableName(name) {
        return "--darkreader-text".concat(name);
      }
      function wrapBorderColorVariableName(name) {
        return "--darkreader-border".concat(name);
      }
      function wrapBgImgVariableName(name) {
        return "--darkreader-bgimg".concat(name);
      }
      function isVariable(property) {
        return property.startsWith("--");
      }
      function isVarDependant(value) {
        return value.includes("var(");
      }
      function isConstructedColorVar(value) {
        return value.match(/^\s*(rgb|hsl)a?\(/);
      }
      function isTextColorProperty(property) {
        return property === "color" || property === "caret-color" || property === "-webkit-text-fill-color";
      }
      var rawValueRegex = /^\d{1,3}, ?\d{1,3}, ?\d{1,3}$/;
      function parseRawValue(color) {
        if (rawValueRegex.test(color)) {
          var splitted = color.split(",");
          var resultInRGB_1 = "rgb(";
          splitted.forEach(function(number) {
            resultInRGB_1 += "".concat(number.trim(), ", ");
          });
          resultInRGB_1 = resultInRGB_1.substring(
            0,
            resultInRGB_1.length - 2
          );
          resultInRGB_1 += ")";
          return { isRaw: true, color: resultInRGB_1 };
        }
        return { isRaw: false, color };
      }
      function handleRawValue(color, theme, modifyFunction) {
        var _a = parseRawValue(color), isRaw = _a.isRaw, newColor = _a.color;
        var rgb = parseColorWithCache(newColor);
        if (rgb) {
          var outputColor = modifyFunction(rgb, theme);
          if (isRaw) {
            var outputInRGB = parseColorWithCache(outputColor);
            return outputInRGB ? "".concat(outputInRGB.r, ", ").concat(outputInRGB.g, ", ").concat(outputInRGB.b) : outputColor;
          }
          return outputColor;
        }
        return newColor;
      }
      function tryModifyBgColor(color, theme) {
        return handleRawValue(color, theme, modifyBackgroundColor);
      }
      function tryModifyTextColor(color, theme) {
        return handleRawValue(color, theme, modifyForegroundColor);
      }
      function tryModifyBorderColor(color, theme) {
        return handleRawValue(color, theme, modifyBorderColor);
      }
      function insertVarValues(source, varValues, stack) {
        if (stack === void 0) {
          stack = /* @__PURE__ */ new Set();
        }
        var containsUnresolvedVar = false;
        var matchReplacer = function(match) {
          var _a = getVariableNameAndFallback(match), name = _a.name, fallback = _a.fallback;
          if (stack.has(name)) {
            containsUnresolvedVar = true;
            return null;
          }
          stack.add(name);
          var varValue = varValues.get(name) || fallback;
          var inserted = null;
          if (varValue) {
            if (isVarDependant(varValue)) {
              inserted = insertVarValues(varValue, varValues, stack);
            } else {
              inserted = varValue;
            }
          }
          if (!inserted) {
            containsUnresolvedVar = true;
            return null;
          }
          return inserted;
        };
        var replaced = replaceVariablesMatches(source, matchReplacer);
        if (containsUnresolvedVar) {
          return null;
        }
        return replaced;
      }
      var overrides = {
        "background-color": {
          customProp: "--darkreader-inline-bgcolor",
          cssProp: "background-color",
          dataAttr: "data-darkreader-inline-bgcolor"
        },
        "background-image": {
          customProp: "--darkreader-inline-bgimage",
          cssProp: "background-image",
          dataAttr: "data-darkreader-inline-bgimage"
        },
        "border-color": {
          customProp: "--darkreader-inline-border",
          cssProp: "border-color",
          dataAttr: "data-darkreader-inline-border"
        },
        "border-bottom-color": {
          customProp: "--darkreader-inline-border-bottom",
          cssProp: "border-bottom-color",
          dataAttr: "data-darkreader-inline-border-bottom"
        },
        "border-left-color": {
          customProp: "--darkreader-inline-border-left",
          cssProp: "border-left-color",
          dataAttr: "data-darkreader-inline-border-left"
        },
        "border-right-color": {
          customProp: "--darkreader-inline-border-right",
          cssProp: "border-right-color",
          dataAttr: "data-darkreader-inline-border-right"
        },
        "border-top-color": {
          customProp: "--darkreader-inline-border-top",
          cssProp: "border-top-color",
          dataAttr: "data-darkreader-inline-border-top"
        },
        "box-shadow": {
          customProp: "--darkreader-inline-boxshadow",
          cssProp: "box-shadow",
          dataAttr: "data-darkreader-inline-boxshadow"
        },
        "color": {
          customProp: "--darkreader-inline-color",
          cssProp: "color",
          dataAttr: "data-darkreader-inline-color"
        },
        "fill": {
          customProp: "--darkreader-inline-fill",
          cssProp: "fill",
          dataAttr: "data-darkreader-inline-fill"
        },
        "stroke": {
          customProp: "--darkreader-inline-stroke",
          cssProp: "stroke",
          dataAttr: "data-darkreader-inline-stroke"
        },
        "outline-color": {
          customProp: "--darkreader-inline-outline",
          cssProp: "outline-color",
          dataAttr: "data-darkreader-inline-outline"
        },
        "stop-color": {
          customProp: "--darkreader-inline-stopcolor",
          cssProp: "stop-color",
          dataAttr: "data-darkreader-inline-stopcolor"
        }
      };
      var overridesList = Object.values(overrides);
      var normalizedPropList = {};
      overridesList.forEach(function(_a) {
        var cssProp = _a.cssProp, customProp = _a.customProp;
        return normalizedPropList[customProp] = cssProp;
      });
      var INLINE_STYLE_ATTRS = [
        "style",
        "fill",
        "stop-color",
        "stroke",
        "bgcolor",
        "color"
      ];
      var INLINE_STYLE_SELECTOR = INLINE_STYLE_ATTRS.map(function(attr) {
        return "[".concat(attr, "]");
      }).join(", ");
      function getInlineOverrideStyle() {
        return overridesList.map(function(_a) {
          var dataAttr = _a.dataAttr, customProp = _a.customProp, cssProp = _a.cssProp;
          return [
            "[".concat(dataAttr, "] {"),
            "  ".concat(cssProp, ": var(").concat(customProp, ") !important;"),
            "}"
          ].join("\n");
        }).join("\n");
      }
      function getInlineStyleElements(root) {
        var results = [];
        if (root instanceof Element && root.matches(INLINE_STYLE_SELECTOR)) {
          results.push(root);
        }
        if (root instanceof Element || isShadowDomSupported && root instanceof ShadowRoot || root instanceof Document) {
          push(results, root.querySelectorAll(INLINE_STYLE_SELECTOR));
        }
        return results;
      }
      var treeObservers = /* @__PURE__ */ new Map();
      var attrObservers = /* @__PURE__ */ new Map();
      function watchForInlineStyles(elementStyleDidChange, shadowRootDiscovered) {
        deepWatchForInlineStyles(
          document,
          elementStyleDidChange,
          shadowRootDiscovered
        );
        iterateShadowHosts(document.documentElement, function(host) {
          deepWatchForInlineStyles(
            host.shadowRoot,
            elementStyleDidChange,
            shadowRootDiscovered
          );
        });
      }
      function deepWatchForInlineStyles(root, elementStyleDidChange, shadowRootDiscovered) {
        if (treeObservers.has(root)) {
          treeObservers.get(root).disconnect();
          attrObservers.get(root).disconnect();
        }
        var discoveredNodes = /* @__PURE__ */ new WeakSet();
        function discoverNodes(node) {
          getInlineStyleElements(node).forEach(function(el) {
            if (discoveredNodes.has(el)) {
              return;
            }
            discoveredNodes.add(el);
            elementStyleDidChange(el);
          });
          iterateShadowHosts(node, function(n) {
            if (discoveredNodes.has(node)) {
              return;
            }
            discoveredNodes.add(node);
            shadowRootDiscovered(n.shadowRoot);
            deepWatchForInlineStyles(
              n.shadowRoot,
              elementStyleDidChange,
              shadowRootDiscovered
            );
          });
        }
        var treeObserver = createOptimizedTreeObserver(root, {
          onMinorMutations: function(_a) {
            var additions = _a.additions;
            additions.forEach(function(added) {
              return discoverNodes(added);
            });
          },
          onHugeMutations: function() {
            discoverNodes(root);
          }
        });
        treeObservers.set(root, treeObserver);
        var attemptCount = 0;
        var start = null;
        var ATTEMPTS_INTERVAL = getDuration({ seconds: 10 });
        var RETRY_TIMEOUT = getDuration({ seconds: 2 });
        var MAX_ATTEMPTS_COUNT = 50;
        var cache = [];
        var timeoutId = null;
        var handleAttributeMutations = throttle(function(mutations) {
          mutations.forEach(function(m) {
            if (INLINE_STYLE_ATTRS.includes(m.attributeName)) {
              elementStyleDidChange(m.target);
            }
          });
        });
        var attrObserver = new MutationObserver(function(mutations) {
          if (timeoutId) {
            cache.push.apply(
              cache,
              __spreadArray([], __read(mutations), false)
            );
            return;
          }
          attemptCount++;
          var now = Date.now();
          if (start == null) {
            start = now;
          } else if (attemptCount >= MAX_ATTEMPTS_COUNT) {
            if (now - start < ATTEMPTS_INTERVAL) {
              timeoutId = setTimeout(function() {
                start = null;
                attemptCount = 0;
                timeoutId = null;
                var attributeCache = cache;
                cache = [];
                handleAttributeMutations(attributeCache);
              }, RETRY_TIMEOUT);
              cache.push.apply(
                cache,
                __spreadArray([], __read(mutations), false)
              );
              return;
            }
            start = now;
            attemptCount = 1;
          }
          handleAttributeMutations(mutations);
        });
        attrObserver.observe(root, {
          attributes: true,
          attributeFilter: INLINE_STYLE_ATTRS.concat(
            overridesList.map(function(_a) {
              var dataAttr = _a.dataAttr;
              return dataAttr;
            })
          ),
          subtree: true
        });
        attrObservers.set(root, attrObserver);
      }
      function stopWatchingForInlineStyles() {
        treeObservers.forEach(function(o) {
          return o.disconnect();
        });
        attrObservers.forEach(function(o) {
          return o.disconnect();
        });
        treeObservers.clear();
        attrObservers.clear();
      }
      var inlineStyleCache = /* @__PURE__ */ new WeakMap();
      var filterProps = ["brightness", "contrast", "grayscale", "sepia", "mode"];
      function getInlineStyleCacheKey(el, theme) {
        return INLINE_STYLE_ATTRS.map(function(attr) {
          return "".concat(attr, '="').concat(el.getAttribute(attr), '"');
        }).concat(
          filterProps.map(function(prop) {
            return "".concat(prop, '="').concat(theme[prop], '"');
          })
        ).join(" ");
      }
      function shouldIgnoreInlineStyle(element, selectors) {
        for (var i = 0, len = selectors.length; i < len; i++) {
          var ingnoredSelector = selectors[i];
          if (element.matches(ingnoredSelector)) {
            return true;
          }
        }
        return false;
      }
      function overrideInlineStyle(element, theme, ignoreInlineSelectors, ignoreImageSelectors) {
        var cacheKey = getInlineStyleCacheKey(element, theme);
        if (cacheKey === inlineStyleCache.get(element)) {
          return;
        }
        var unsetProps = new Set(Object.keys(overrides));
        function setCustomProp(targetCSSProp, modifierCSSProp, cssVal) {
          var isPropertyVariable = targetCSSProp.startsWith("--");
          var _a = isPropertyVariable ? {} : overrides[targetCSSProp], customProp = _a.customProp, dataAttr = _a.dataAttr;
          var mod = getModifiableCSSDeclaration(
            modifierCSSProp,
            cssVal,
            { style: element.style },
            variablesStore,
            ignoreImageSelectors,
            null
          );
          if (!mod) {
            return;
          }
          var value2 = mod.value;
          if (typeof value2 === "function") {
            value2 = value2(theme);
          }
          if (isPropertyVariable && typeof value2 === "object") {
            var typedValue = value2;
            typedValue.declarations.forEach(function(_a2) {
              var property = _a2.property, value3 = _a2.value;
              !(value3 instanceof Promise) && element.style.setProperty(property, value3);
            });
          } else {
            element.style.setProperty(customProp, value2);
            if (!element.hasAttribute(dataAttr)) {
              element.setAttribute(dataAttr, "");
            }
            unsetProps.delete(targetCSSProp);
          }
        }
        if (ignoreInlineSelectors.length > 0) {
          if (shouldIgnoreInlineStyle(element, ignoreInlineSelectors)) {
            unsetProps.forEach(function(cssProp) {
              element.removeAttribute(overrides[cssProp].dataAttr);
            });
            return;
          }
        }
        if (element.hasAttribute("bgcolor")) {
          var value = element.getAttribute("bgcolor");
          if (value.match(/^[0-9a-f]{3}$/i) || value.match(/^[0-9a-f]{6}$/i)) {
            value = "#".concat(value);
          }
          setCustomProp("background-color", "background-color", value);
        }
        if (element.hasAttribute("color") && element.rel !== "mask-icon") {
          var value = element.getAttribute("color");
          if (value.match(/^[0-9a-f]{3}$/i) || value.match(/^[0-9a-f]{6}$/i)) {
            value = "#".concat(value);
          }
          setCustomProp("color", "color", value);
        }
        if (element instanceof SVGElement) {
          if (element.hasAttribute("fill")) {
            var SMALL_SVG_LIMIT_1 = 32;
            var value_1 = element.getAttribute("fill");
            if (value_1 !== "none") {
              if (!(element instanceof SVGTextElement)) {
                var handleSVGElement = function() {
                  var _a = element.getBoundingClientRect(), width = _a.width, height = _a.height;
                  var isBg = width > SMALL_SVG_LIMIT_1 || height > SMALL_SVG_LIMIT_1;
                  setCustomProp(
                    "fill",
                    isBg ? "background-color" : "color",
                    value_1
                  );
                };
                if (isReadyStateComplete()) {
                  handleSVGElement();
                } else {
                  addReadyStateCompleteListener(handleSVGElement);
                }
              } else {
                setCustomProp("fill", "color", value_1);
              }
            }
          }
          if (element.hasAttribute("stop-color")) {
            setCustomProp(
              "stop-color",
              "background-color",
              element.getAttribute("stop-color")
            );
          }
        }
        if (element.hasAttribute("stroke")) {
          var value = element.getAttribute("stroke");
          setCustomProp(
            "stroke",
            element instanceof SVGLineElement || element instanceof SVGTextElement ? "border-color" : "color",
            value
          );
        }
        element.style && iterateCSSDeclarations(element.style, function(property, value2) {
          if (property === "background-image" && value2.includes("url")) {
            return;
          }
          if (overrides.hasOwnProperty(property) || property.startsWith("--") && !normalizedPropList[property]) {
            setCustomProp(property, property, value2);
          } else {
            var overridenProp = normalizedPropList[property];
            if (overridenProp && !element.style.getPropertyValue(overridenProp) && !element.hasAttribute(overridenProp)) {
              if (overridenProp === "background-color" && element.hasAttribute("bgcolor")) {
                return;
              }
              element.style.setProperty(property, "");
            }
          }
        });
        if (element.style && element instanceof SVGTextElement && element.style.fill) {
          setCustomProp(
            "fill",
            "color",
            element.style.getPropertyValue("fill")
          );
        }
        forEach(unsetProps, function(cssProp) {
          element.removeAttribute(overrides[cssProp].dataAttr);
        });
        inlineStyleCache.set(element, getInlineStyleCacheKey(element, theme));
      }
      var metaThemeColorName = "theme-color";
      var metaThemeColorSelector = 'meta[name="'.concat(metaThemeColorName, '"]');
      var srcMetaThemeColor = null;
      var observer = null;
      function changeMetaThemeColor(meta, theme) {
        srcMetaThemeColor = srcMetaThemeColor || meta.content;
        var color = parseColorWithCache(srcMetaThemeColor);
        if (!color) {
          return;
        }
        meta.content = modifyBackgroundColor(color, theme);
      }
      function changeMetaThemeColorWhenAvailable(theme) {
        var meta = document.querySelector(metaThemeColorSelector);
        if (meta) {
          changeMetaThemeColor(meta, theme);
        } else {
          if (observer) {
            observer.disconnect();
          }
          observer = new MutationObserver(function(mutations) {
            loop:
              for (var i = 0; i < mutations.length; i++) {
                var addedNodes = mutations[i].addedNodes;
                for (var j = 0; j < addedNodes.length; j++) {
                  var node = addedNodes[j];
                  if (node instanceof HTMLMetaElement && node.name === metaThemeColorName) {
                    observer.disconnect();
                    observer = null;
                    changeMetaThemeColor(node, theme);
                    break loop;
                  }
                }
              }
          });
          observer.observe(document.head, { childList: true });
        }
      }
      function restoreMetaThemeColor() {
        if (observer) {
          observer.disconnect();
          observer = null;
        }
        var meta = document.querySelector(metaThemeColorSelector);
        if (meta && srcMetaThemeColor) {
          meta.content = srcMetaThemeColor;
        }
      }
      var themeCacheKeys = [
        "mode",
        "brightness",
        "contrast",
        "grayscale",
        "sepia",
        "darkSchemeBackgroundColor",
        "darkSchemeTextColor",
        "lightSchemeBackgroundColor",
        "lightSchemeTextColor"
      ];
      function getThemeKey(theme) {
        var resultKey = "";
        themeCacheKeys.forEach(function(key) {
          resultKey += "".concat(key, ":").concat(theme[key], ";");
        });
        return resultKey;
      }
      var asyncQueue = createAsyncTasksQueue();
      function createStyleSheetModifier() {
        var renderId = 0;
        var rulesTextCache = /* @__PURE__ */ new Set();
        var rulesModCache = /* @__PURE__ */ new Map();
        var varTypeChangeCleaners = /* @__PURE__ */ new Set();
        var prevFilterKey = null;
        var hasNonLoadedLink = false;
        var wasRebuilt = false;
        function shouldRebuildStyle() {
          return hasNonLoadedLink && !wasRebuilt;
        }
        function modifySheet(options) {
          var rules = options.sourceCSSRules;
          var theme = options.theme, ignoreImageAnalysis = options.ignoreImageAnalysis, force = options.force, prepareSheet = options.prepareSheet, isAsyncCancelled = options.isAsyncCancelled;
          var rulesChanged = rulesModCache.size === 0;
          var notFoundCacheKeys = new Set(rulesModCache.keys());
          var themeKey = getThemeKey(theme);
          var themeChanged = themeKey !== prevFilterKey;
          if (hasNonLoadedLink) {
            wasRebuilt = true;
          }
          var modRules = [];
          iterateCSSRules(
            rules,
            function(rule) {
              var cssText = rule.cssText;
              var textDiffersFromPrev = false;
              notFoundCacheKeys.delete(cssText);
              if (rule.parentRule instanceof CSSMediaRule) {
                cssText += ";".concat(rule.parentRule.media.mediaText);
              }
              if (!rulesTextCache.has(cssText)) {
                rulesTextCache.add(cssText);
                textDiffersFromPrev = true;
              }
              if (textDiffersFromPrev) {
                rulesChanged = true;
              } else {
                modRules.push(rulesModCache.get(cssText));
                return;
              }
              var modDecs = [];
              rule.style && iterateCSSDeclarations(
                rule.style,
                function(property, value) {
                  var mod = getModifiableCSSDeclaration(
                    property,
                    value,
                    rule,
                    variablesStore,
                    ignoreImageAnalysis,
                    isAsyncCancelled
                  );
                  if (mod) {
                    modDecs.push(mod);
                  }
                }
              );
              var modRule = null;
              if (modDecs.length > 0) {
                var parentRule = rule.parentRule;
                modRule = {
                  selector: rule.selectorText,
                  declarations: modDecs,
                  parentRule
                };
                modRules.push(modRule);
              }
              rulesModCache.set(cssText, modRule);
            },
            function() {
              hasNonLoadedLink = true;
            }
          );
          notFoundCacheKeys.forEach(function(key) {
            rulesTextCache.delete(key);
            rulesModCache.delete(key);
          });
          prevFilterKey = themeKey;
          if (!force && !rulesChanged && !themeChanged) {
            return;
          }
          renderId++;
          function setRule(target, index, rule) {
            var selector = rule.selector, declarations = rule.declarations;
            var getDeclarationText = function(dec) {
              var property = dec.property, value = dec.value, important = dec.important, sourceValue = dec.sourceValue;
              return "".concat(property, ": ").concat(value == null ? sourceValue : value).concat(important ? " !important" : "", ";");
            };
            var cssRulesText = "";
            declarations.forEach(function(declarations2) {
              cssRulesText += "".concat(
                getDeclarationText(declarations2),
                " "
              );
            });
            var ruleText = "".concat(selector, " { ").concat(cssRulesText, " }");
            target.insertRule(ruleText, index);
          }
          var asyncDeclarations = /* @__PURE__ */ new Map();
          var varDeclarations = /* @__PURE__ */ new Map();
          var asyncDeclarationCounter = 0;
          var varDeclarationCounter = 0;
          var rootReadyGroup = { rule: null, rules: [], isGroup: true };
          var groupRefs = /* @__PURE__ */ new WeakMap();
          function getGroup(rule) {
            if (rule == null) {
              return rootReadyGroup;
            }
            if (groupRefs.has(rule)) {
              return groupRefs.get(rule);
            }
            var group = { rule, rules: [], isGroup: true };
            groupRefs.set(rule, group);
            var parentGroup = getGroup(rule.parentRule);
            parentGroup.rules.push(group);
            return group;
          }
          varTypeChangeCleaners.forEach(function(clear) {
            return clear();
          });
          varTypeChangeCleaners.clear();
          modRules.filter(function(r) {
            return r;
          }).forEach(function(_a) {
            var selector = _a.selector, declarations = _a.declarations, parentRule = _a.parentRule;
            var group = getGroup(parentRule);
            var readyStyleRule = {
              selector,
              declarations: [],
              isGroup: false
            };
            var readyDeclarations = readyStyleRule.declarations;
            group.rules.push(readyStyleRule);
            function handleAsyncDeclaration(property, modified, important, sourceValue) {
              var asyncKey = ++asyncDeclarationCounter;
              var asyncDeclaration = {
                property,
                value: null,
                important,
                asyncKey,
                sourceValue
              };
              readyDeclarations.push(asyncDeclaration);
              var currentRenderId = renderId;
              modified.then(function(asyncValue) {
                if (!asyncValue || isAsyncCancelled() || currentRenderId !== renderId) {
                  return;
                }
                asyncDeclaration.value = asyncValue;
                asyncQueue.add(function() {
                  if (isAsyncCancelled() || currentRenderId !== renderId) {
                    return;
                  }
                  rebuildAsyncRule(asyncKey);
                });
              });
            }
            function handleVarDeclarations(property, modified, important, sourceValue) {
              var _a2 = modified, varDecs = _a2.declarations, onTypeChange = _a2.onTypeChange;
              var varKey = ++varDeclarationCounter;
              var currentRenderId = renderId;
              var initialIndex = readyDeclarations.length;
              var oldDecs = [];
              if (varDecs.length === 0) {
                var tempDec = {
                  property,
                  value: sourceValue,
                  important,
                  sourceValue,
                  varKey
                };
                readyDeclarations.push(tempDec);
                oldDecs = [tempDec];
              }
              varDecs.forEach(function(mod) {
                if (mod.value instanceof Promise) {
                  handleAsyncDeclaration(
                    mod.property,
                    mod.value,
                    important,
                    sourceValue
                  );
                } else {
                  var readyDec = {
                    property: mod.property,
                    value: mod.value,
                    important,
                    sourceValue,
                    varKey
                  };
                  readyDeclarations.push(readyDec);
                  oldDecs.push(readyDec);
                }
              });
              onTypeChange.addListener(function(newDecs) {
                if (isAsyncCancelled() || currentRenderId !== renderId) {
                  return;
                }
                var readyVarDecs = newDecs.map(function(mod) {
                  return {
                    property: mod.property,
                    value: mod.value,
                    important,
                    sourceValue,
                    varKey
                  };
                });
                var index = readyDeclarations.indexOf(
                  oldDecs[0],
                  initialIndex
                );
                readyDeclarations.splice.apply(
                  readyDeclarations,
                  __spreadArray(
                    [index, oldDecs.length],
                    __read(readyVarDecs),
                    false
                  )
                );
                oldDecs = readyVarDecs;
                rebuildVarRule(varKey);
              });
              varTypeChangeCleaners.add(function() {
                return onTypeChange.removeListeners();
              });
            }
            declarations.forEach(function(_a2) {
              var property = _a2.property, value = _a2.value, important = _a2.important, sourceValue = _a2.sourceValue;
              if (typeof value === "function") {
                var modified = value(theme);
                if (modified instanceof Promise) {
                  handleAsyncDeclaration(
                    property,
                    modified,
                    important,
                    sourceValue
                  );
                } else if (property.startsWith("--")) {
                  handleVarDeclarations(
                    property,
                    modified,
                    important,
                    sourceValue
                  );
                } else {
                  readyDeclarations.push({
                    property,
                    value: modified,
                    important,
                    sourceValue
                  });
                }
              } else {
                readyDeclarations.push({
                  property,
                  value,
                  important,
                  sourceValue
                });
              }
            });
          });
          var sheet = prepareSheet();
          function buildStyleSheet() {
            function createTarget(group, parent) {
              var rule = group.rule;
              if (rule instanceof CSSMediaRule) {
                var media = rule.media;
                var index = parent.cssRules.length;
                parent.insertRule(
                  "@media ".concat(media.mediaText, " {}"),
                  index
                );
                return parent.cssRules[index];
              }
              return parent;
            }
            function iterateReadyRules(group, target, styleIterator) {
              group.rules.forEach(function(r) {
                if (r.isGroup) {
                  var t = createTarget(r, target);
                  iterateReadyRules(r, t, styleIterator);
                } else {
                  styleIterator(r, target);
                }
              });
            }
            iterateReadyRules(
              rootReadyGroup,
              sheet,
              function(rule, target) {
                var index = target.cssRules.length;
                rule.declarations.forEach(function(_a) {
                  var asyncKey = _a.asyncKey, varKey = _a.varKey;
                  if (asyncKey != null) {
                    asyncDeclarations.set(asyncKey, {
                      rule,
                      target,
                      index
                    });
                  }
                  if (varKey != null) {
                    varDeclarations.set(varKey, {
                      rule,
                      target,
                      index
                    });
                  }
                });
                setRule(target, index, rule);
              }
            );
          }
          function rebuildAsyncRule(key) {
            var _a = asyncDeclarations.get(key), rule = _a.rule, target = _a.target, index = _a.index;
            target.deleteRule(index);
            setRule(target, index, rule);
            asyncDeclarations.delete(key);
          }
          function rebuildVarRule(key) {
            var _a = varDeclarations.get(key), rule = _a.rule, target = _a.target, index = _a.index;
            target.deleteRule(index);
            setRule(target, index, rule);
          }
          buildStyleSheet();
        }
        return {
          modifySheet,
          shouldRebuildStyle
        };
      }
      var STYLE_SELECTOR = 'style, link[rel*="stylesheet" i]:not([disabled])';
      function isFontsGoogleApiStyle(element) {
        if (!element.href) {
          return false;
        }
        try {
          var elementURL = new URL(element.href);
          return elementURL.hostname === "fonts.googleapis.com";
        } catch (err) {
          logInfo("Couldn't construct ".concat(element.href, " as URL"));
          return false;
        }
      }
      function shouldManageStyle(element) {
        return (element instanceof HTMLStyleElement || element instanceof SVGStyleElement || element instanceof HTMLLinkElement && element.rel && element.rel.toLowerCase().includes("stylesheet") && element.href && !element.disabled && (isFirefox ? !element.href.startsWith("moz-extension://") : true) && !isFontsGoogleApiStyle(element)) && !element.classList.contains("darkreader") && element.media.toLowerCase() !== "print" && !element.classList.contains("stylus");
      }
      function getManageableStyles(node, results, deep) {
        if (results === void 0) {
          results = [];
        }
        if (deep === void 0) {
          deep = true;
        }
        if (shouldManageStyle(node)) {
          results.push(node);
        } else if (node instanceof Element || isShadowDomSupported && node instanceof ShadowRoot || node === document) {
          forEach(node.querySelectorAll(STYLE_SELECTOR), function(style) {
            return getManageableStyles(style, results, false);
          });
          if (deep) {
            iterateShadowHosts(node, function(host) {
              return getManageableStyles(host.shadowRoot, results, false);
            });
          }
        }
        return results;
      }
      var syncStyleSet = /* @__PURE__ */ new WeakSet();
      var corsStyleSet = /* @__PURE__ */ new WeakSet();
      var canOptimizeUsingProxy$1 = false;
      document.addEventListener(
        "__darkreader__inlineScriptsAllowed",
        function() {
          canOptimizeUsingProxy$1 = true;
        }
      );
      var loadingLinkCounter = 0;
      var rejectorsForLoadingLinks = /* @__PURE__ */ new Map();
      function cleanLoadingLinks() {
        rejectorsForLoadingLinks.clear();
      }
      function manageStyle(element, _a) {
        var update = _a.update, loadingStart = _a.loadingStart, loadingEnd = _a.loadingEnd;
        var prevStyles = [];
        var next = element;
        while ((next = next.nextElementSibling) && next.matches(".darkreader")) {
          prevStyles.push(next);
        }
        var corsCopy = prevStyles.find(function(el) {
          return el.matches(".darkreader--cors") && !corsStyleSet.has(el);
        }) || null;
        var syncStyle = prevStyles.find(function(el) {
          return el.matches(".darkreader--sync") && !syncStyleSet.has(el);
        }) || null;
        var corsCopyPositionWatcher = null;
        var syncStylePositionWatcher = null;
        var cancelAsyncOperations = false;
        var isOverrideEmpty = true;
        var sheetModifier = createStyleSheetModifier();
        var observer2 = new MutationObserver(function() {
          update();
        });
        var observerOptions = {
          attributes: true,
          childList: true,
          subtree: true,
          characterData: true
        };
        function containsCSSImport() {
          return element instanceof HTMLStyleElement && element.textContent.trim().match(cssImportRegex);
        }
        function hasImports(cssRules, checkCrossOrigin) {
          var result = false;
          if (cssRules) {
            var rule = void 0;
            cssRulesLoop:
              for (var i = 0, len = cssRules.length; i < len; i++) {
                rule = cssRules[i];
                if (rule.href) {
                  if (checkCrossOrigin) {
                    if (rule.href.startsWith("http") && !rule.href.startsWith(location.origin)) {
                      result = true;
                      break cssRulesLoop;
                    }
                  } else {
                    result = true;
                    break cssRulesLoop;
                  }
                }
              }
          }
          return result;
        }
        function getRulesSync() {
          if (corsCopy) {
            return corsCopy.sheet.cssRules;
          }
          if (containsCSSImport()) {
            return null;
          }
          var cssRules = safeGetSheetRules();
          if (element instanceof HTMLLinkElement && !isRelativeHrefOnAbsolutePath(element.href) && hasImports(cssRules, false)) {
            return null;
          }
          if (hasImports(cssRules, true)) {
            return null;
          }
          return cssRules;
        }
        function insertStyle() {
          if (corsCopy) {
            if (element.nextSibling !== corsCopy) {
              element.parentNode.insertBefore(
                corsCopy,
                element.nextSibling
              );
            }
            if (corsCopy.nextSibling !== syncStyle) {
              element.parentNode.insertBefore(
                syncStyle,
                corsCopy.nextSibling
              );
            }
          } else if (element.nextSibling !== syncStyle) {
            element.parentNode.insertBefore(syncStyle, element.nextSibling);
          }
        }
        function createSyncStyle() {
          syncStyle = element instanceof SVGStyleElement ? document.createElementNS(
            "http://www.w3.org/2000/svg",
            "style"
          ) : document.createElement("style");
          syncStyle.classList.add("darkreader");
          syncStyle.classList.add("darkreader--sync");
          syncStyle.media = "screen";
          if (element.title) {
            syncStyle.title = element.title;
          }
          syncStyleSet.add(syncStyle);
        }
        var isLoadingRules = false;
        var wasLoadingError = false;
        var loadingLinkId = ++loadingLinkCounter;
        function getRulesAsync() {
          return __awaiter(this, void 0, void 0, function() {
            var cssText, cssBasePath, _a2, cssRules, accessError, fullCSSText;
            var _b;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  if (!(element instanceof HTMLLinkElement))
                    return [3, 7];
                  _a2 = __read(getRulesOrError(), 2), cssRules = _a2[0], accessError = _a2[1];
                  if (!(!cssRules && !accessError && !isSafari || isSafari && !element.sheet || isStillLoadingError(accessError)))
                    return [3, 5];
                  _c.label = 1;
                case 1:
                  _c.trys.push([1, 3, , 4]);
                  return [4, linkLoading(element, loadingLinkId)];
                case 2:
                  _c.sent();
                  return [3, 4];
                case 3:
                  _c.sent();
                  wasLoadingError = true;
                  return [3, 4];
                case 4:
                  if (cancelAsyncOperations) {
                    return [2, null];
                  }
                  _b = __read(getRulesOrError(), 2), cssRules = _b[0], accessError = _b[1];
                  _c.label = 5;
                case 5:
                  if (cssRules) {
                    if (!hasImports(cssRules, false)) {
                      return [2, cssRules];
                    }
                  }
                  return [4, loadText(element.href)];
                case 6:
                  cssText = _c.sent();
                  cssBasePath = getCSSBaseBath(element.href);
                  if (cancelAsyncOperations) {
                    return [2, null];
                  }
                  return [3, 8];
                case 7:
                  if (containsCSSImport()) {
                    cssText = element.textContent.trim();
                    cssBasePath = getCSSBaseBath(location.href);
                  } else {
                    return [2, null];
                  }
                  _c.label = 8;
                case 8:
                  if (!cssText)
                    return [3, 13];
                  _c.label = 9;
                case 9:
                  _c.trys.push([9, 11, , 12]);
                  return [4, replaceCSSImports(cssText, cssBasePath)];
                case 10:
                  fullCSSText = _c.sent();
                  corsCopy = createCORSCopy(element, fullCSSText);
                  return [3, 12];
                case 11:
                  _c.sent();
                  return [3, 12];
                case 12:
                  if (corsCopy) {
                    corsCopyPositionWatcher = watchForNodePosition(
                      corsCopy,
                      "prev-sibling"
                    );
                    return [2, corsCopy.sheet.cssRules];
                  }
                  _c.label = 13;
                case 13:
                  return [2, null];
              }
            });
          });
        }
        function details(options) {
          var rules = getRulesSync();
          if (!rules) {
            if (options.secondRound) {
              return null;
            }
            if (isLoadingRules || wasLoadingError) {
              return null;
            }
            isLoadingRules = true;
            loadingStart();
            getRulesAsync().then(function(results) {
              isLoadingRules = false;
              loadingEnd();
              if (results) {
                update();
              }
            }).catch(function(err) {
              isLoadingRules = false;
              loadingEnd();
            });
            return null;
          }
          return { rules };
        }
        var forceRenderStyle = false;
        function render(theme, ignoreImageAnalysis) {
          var rules = getRulesSync();
          if (!rules) {
            return;
          }
          cancelAsyncOperations = false;
          function removeCSSRulesFromSheet(sheet) {
            for (var i = sheet.cssRules.length - 1; i >= 0; i--) {
              sheet.deleteRule(i);
            }
          }
          function prepareOverridesSheet() {
            if (!syncStyle) {
              createSyncStyle();
            }
            syncStylePositionWatcher && syncStylePositionWatcher.stop();
            insertStyle();
            if (syncStyle.sheet == null) {
              syncStyle.textContent = "";
            }
            var sheet = syncStyle.sheet;
            removeCSSRulesFromSheet(sheet);
            if (syncStylePositionWatcher) {
              syncStylePositionWatcher.run();
            } else {
              syncStylePositionWatcher = watchForNodePosition(
                syncStyle,
                "prev-sibling",
                function() {
                  forceRenderStyle = true;
                  buildOverrides();
                }
              );
            }
            return syncStyle.sheet;
          }
          function buildOverrides() {
            var force = forceRenderStyle;
            forceRenderStyle = false;
            sheetModifier.modifySheet({
              prepareSheet: prepareOverridesSheet,
              sourceCSSRules: rules,
              theme,
              ignoreImageAnalysis,
              force,
              isAsyncCancelled: function() {
                return cancelAsyncOperations;
              }
            });
            isOverrideEmpty = syncStyle.sheet.cssRules.length === 0;
            if (sheetModifier.shouldRebuildStyle()) {
              addReadyStateCompleteListener(function() {
                return update();
              });
            }
          }
          buildOverrides();
        }
        function getRulesOrError() {
          try {
            if (element.sheet == null) {
              return [null, null];
            }
            return [element.sheet.cssRules, null];
          } catch (err) {
            return [null, err];
          }
        }
        function isStillLoadingError(error) {
          return error && error.message && error.message.includes("loading");
        }
        function safeGetSheetRules() {
          var _a2 = __read(getRulesOrError(), 2), cssRules = _a2[0], err = _a2[1];
          if (err) {
            return null;
          }
          return cssRules;
        }
        function watchForSheetChanges() {
          watchForSheetChangesUsingProxy();
          if (!(canOptimizeUsingProxy$1 && element.sheet)) {
            watchForSheetChangesUsingRAF();
          }
        }
        var rulesChangeKey = null;
        var rulesCheckFrameId = null;
        function getRulesChangeKey() {
          var rules = safeGetSheetRules();
          return rules ? rules.length : null;
        }
        function didRulesKeyChange() {
          return getRulesChangeKey() !== rulesChangeKey;
        }
        function watchForSheetChangesUsingRAF() {
          rulesChangeKey = getRulesChangeKey();
          stopWatchingForSheetChangesUsingRAF();
          var checkForUpdate = function() {
            if (didRulesKeyChange()) {
              rulesChangeKey = getRulesChangeKey();
              update();
            }
            if (canOptimizeUsingProxy$1 && element.sheet) {
              stopWatchingForSheetChangesUsingRAF();
              return;
            }
            rulesCheckFrameId = requestAnimationFrame(checkForUpdate);
          };
          checkForUpdate();
        }
        function stopWatchingForSheetChangesUsingRAF() {
          cancelAnimationFrame(rulesCheckFrameId);
        }
        var areSheetChangesPending = false;
        function onSheetChange() {
          canOptimizeUsingProxy$1 = true;
          stopWatchingForSheetChangesUsingRAF();
          if (areSheetChangesPending) {
            return;
          }
          function handleSheetChanges() {
            areSheetChangesPending = false;
            if (cancelAsyncOperations) {
              return;
            }
            update();
          }
          areSheetChangesPending = true;
          if (typeof queueMicrotask === "function") {
            queueMicrotask(handleSheetChanges);
          } else {
            requestAnimationFrame(handleSheetChanges);
          }
        }
        function watchForSheetChangesUsingProxy() {
          element.addEventListener(
            "__darkreader__updateSheet",
            onSheetChange
          );
        }
        function stopWatchingForSheetChangesUsingProxy() {
          element.removeEventListener(
            "__darkreader__updateSheet",
            onSheetChange
          );
        }
        function stopWatchingForSheetChanges() {
          stopWatchingForSheetChangesUsingProxy();
          stopWatchingForSheetChangesUsingRAF();
        }
        function pause() {
          observer2.disconnect();
          cancelAsyncOperations = true;
          corsCopyPositionWatcher && corsCopyPositionWatcher.stop();
          syncStylePositionWatcher && syncStylePositionWatcher.stop();
          stopWatchingForSheetChanges();
        }
        function destroy() {
          pause();
          removeNode(corsCopy);
          removeNode(syncStyle);
          loadingEnd();
          if (rejectorsForLoadingLinks.has(loadingLinkId)) {
            var reject = rejectorsForLoadingLinks.get(loadingLinkId);
            rejectorsForLoadingLinks.delete(loadingLinkId);
            reject && reject();
          }
        }
        function watch() {
          observer2.observe(element, observerOptions);
          if (element instanceof HTMLStyleElement) {
            watchForSheetChanges();
          }
        }
        var maxMoveCount = 10;
        var moveCount = 0;
        function restore() {
          if (!syncStyle) {
            return;
          }
          moveCount++;
          if (moveCount > maxMoveCount) {
            return;
          }
          insertStyle();
          corsCopyPositionWatcher && corsCopyPositionWatcher.skip();
          syncStylePositionWatcher && syncStylePositionWatcher.skip();
          if (!isOverrideEmpty) {
            forceRenderStyle = true;
            update();
          }
        }
        return {
          details,
          render,
          pause,
          destroy,
          watch,
          restore
        };
      }
      function linkLoading(link, loadingId) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [
              2,
              new Promise(function(resolve, reject) {
                var cleanUp = function() {
                  link.removeEventListener("load", onLoad);
                  link.removeEventListener("error", onError);
                  rejectorsForLoadingLinks.delete(loadingId);
                };
                var onLoad = function() {
                  cleanUp();
                  resolve();
                };
                var onError = function() {
                  cleanUp();
                  reject(
                    "Linkelement ".concat(loadingId, " couldn't be loaded. ").concat(link.href)
                  );
                };
                rejectorsForLoadingLinks.set(loadingId, function() {
                  cleanUp();
                  reject();
                });
                link.addEventListener("load", onLoad);
                link.addEventListener("error", onError);
                if (!link.href) {
                  onError();
                }
              })
            ];
          });
        });
      }
      function getCSSImportURL(importDeclaration) {
        return getCSSURLValue(
          importDeclaration.substring(7).trim().replace(/;$/, "").replace(/screen$/, "")
        );
      }
      function loadText(url) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!url.startsWith("data:"))
                  return [3, 3];
                return [4, fetch(url)];
              case 1:
                return [4, _a.sent().text()];
              case 2:
                return [2, _a.sent()];
              case 3:
                return [
                  4,
                  bgFetch({
                    url,
                    responseType: "text",
                    mimeType: "text/css",
                    origin: window.location.origin
                  })
                ];
              case 4:
                return [2, _a.sent()];
            }
          });
        });
      }
      function replaceCSSImports(cssText, basePath, cache) {
        if (cache === void 0) {
          cache = /* @__PURE__ */ new Map();
        }
        return __awaiter(this, void 0, void 0, function() {
          var importMatches, importMatches_1, importMatches_1_1, match, importURL, absoluteURL, importedCSS, e_1_1;
          var e_1, _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                cssText = removeCSSComments(cssText);
                cssText = replaceCSSFontFace(cssText);
                cssText = replaceCSSRelativeURLsWithAbsolute(
                  cssText,
                  basePath
                );
                importMatches = getMatches(cssImportRegex, cssText);
                _b.label = 1;
              case 1:
                _b.trys.push([1, 10, 11, 12]);
                importMatches_1 = __values(importMatches), importMatches_1_1 = importMatches_1.next();
                _b.label = 2;
              case 2:
                if (!!importMatches_1_1.done)
                  return [3, 9];
                match = importMatches_1_1.value;
                importURL = getCSSImportURL(match);
                absoluteURL = getAbsoluteURL(basePath, importURL);
                importedCSS = void 0;
                if (!cache.has(absoluteURL))
                  return [3, 3];
                importedCSS = cache.get(absoluteURL);
                return [3, 7];
              case 3:
                _b.trys.push([3, 6, , 7]);
                return [4, loadText(absoluteURL)];
              case 4:
                importedCSS = _b.sent();
                cache.set(absoluteURL, importedCSS);
                return [
                  4,
                  replaceCSSImports(
                    importedCSS,
                    getCSSBaseBath(absoluteURL),
                    cache
                  )
                ];
              case 5:
                importedCSS = _b.sent();
                return [3, 7];
              case 6:
                _b.sent();
                importedCSS = "";
                return [3, 7];
              case 7:
                cssText = cssText.split(match).join(importedCSS);
                _b.label = 8;
              case 8:
                importMatches_1_1 = importMatches_1.next();
                return [3, 2];
              case 9:
                return [3, 12];
              case 10:
                e_1_1 = _b.sent();
                e_1 = { error: e_1_1 };
                return [3, 12];
              case 11:
                try {
                  if (importMatches_1_1 && !importMatches_1_1.done && (_a = importMatches_1.return))
                    _a.call(importMatches_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
                return [7];
              case 12:
                cssText = cssText.trim();
                return [2, cssText];
            }
          });
        });
      }
      function createCORSCopy(srcElement, cssText) {
        if (!cssText) {
          return null;
        }
        var cors = document.createElement("style");
        cors.classList.add("darkreader");
        cors.classList.add("darkreader--cors");
        cors.media = "screen";
        cors.textContent = cssText;
        srcElement.parentNode.insertBefore(cors, srcElement.nextSibling);
        cors.sheet.disabled = true;
        corsStyleSet.add(cors);
        return cors;
      }
      var observers = [];
      var observedRoots;
      var undefinedGroups = /* @__PURE__ */ new Map();
      var elementsDefinitionCallback;
      function collectUndefinedElements(root) {
        if (!isDefinedSelectorSupported) {
          return;
        }
        forEach(root.querySelectorAll(":not(:defined)"), function(el) {
          var tag = el.tagName.toLowerCase();
          if (!tag.includes("-")) {
            var extendedTag = el.getAttribute("is");
            if (extendedTag) {
              tag = extendedTag;
            } else {
              return;
            }
          }
          if (!undefinedGroups.has(tag)) {
            undefinedGroups.set(tag, /* @__PURE__ */ new Set());
            customElementsWhenDefined(tag).then(function() {
              if (elementsDefinitionCallback) {
                var elements = undefinedGroups.get(tag);
                undefinedGroups.delete(tag);
                elementsDefinitionCallback(Array.from(elements));
              }
            });
          }
          undefinedGroups.get(tag).add(el);
        });
      }
      var canOptimizeUsingProxy = false;
      document.addEventListener(
        "__darkreader__inlineScriptsAllowed",
        function() {
          canOptimizeUsingProxy = true;
        }
      );
      var resolvers = /* @__PURE__ */ new Map();
      function handleIsDefined(e) {
        canOptimizeUsingProxy = true;
        if (resolvers.has(e.detail.tag)) {
          var resolve = resolvers.get(e.detail.tag);
          resolve();
        }
      }
      function customElementsWhenDefined(tag) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [
              2,
              new Promise(function(resolve) {
                if (window.customElements && typeof customElements.whenDefined === "function") {
                  customElements.whenDefined(tag).then(function() {
                    return resolve();
                  });
                } else if (canOptimizeUsingProxy) {
                  resolvers.set(tag, resolve);
                  document.dispatchEvent(
                    new CustomEvent(
                      "__darkreader__addUndefinedResolver",
                      { detail: { tag } }
                    )
                  );
                } else {
                  var checkIfDefined_1 = function() {
                    var elements = undefinedGroups.get(tag);
                    if (elements && elements.size > 0) {
                      if (elements.values().next().value.matches(":defined")) {
                        resolve();
                      } else {
                        requestAnimationFrame(checkIfDefined_1);
                      }
                    }
                  };
                  requestAnimationFrame(checkIfDefined_1);
                }
              })
            ];
          });
        });
      }
      function watchWhenCustomElementsDefined(callback) {
        elementsDefinitionCallback = callback;
      }
      function unsubscribeFromDefineCustomElements() {
        elementsDefinitionCallback = null;
        undefinedGroups.clear();
        document.removeEventListener(
          "__darkreader__isDefined",
          handleIsDefined
        );
      }
      function watchForStyleChanges(currentStyles, update, shadowRootDiscovered) {
        stopWatchingForStyleChanges();
        var prevStyles = new Set(currentStyles);
        var prevStyleSiblings = /* @__PURE__ */ new WeakMap();
        var nextStyleSiblings = /* @__PURE__ */ new WeakMap();
        function saveStylePosition(style) {
          prevStyleSiblings.set(style, style.previousElementSibling);
          nextStyleSiblings.set(style, style.nextElementSibling);
        }
        function forgetStylePosition(style) {
          prevStyleSiblings.delete(style);
          nextStyleSiblings.delete(style);
        }
        function didStylePositionChange(style) {
          return style.previousElementSibling !== prevStyleSiblings.get(style) || style.nextElementSibling !== nextStyleSiblings.get(style);
        }
        currentStyles.forEach(saveStylePosition);
        function handleStyleOperations(operations) {
          var createdStyles = operations.createdStyles, removedStyles = operations.removedStyles, movedStyles = operations.movedStyles;
          createdStyles.forEach(function(s) {
            return saveStylePosition(s);
          });
          movedStyles.forEach(function(s) {
            return saveStylePosition(s);
          });
          removedStyles.forEach(function(s) {
            return forgetStylePosition(s);
          });
          createdStyles.forEach(function(s) {
            return prevStyles.add(s);
          });
          removedStyles.forEach(function(s) {
            return prevStyles.delete(s);
          });
          if (createdStyles.size + removedStyles.size + movedStyles.size > 0) {
            update({
              created: Array.from(createdStyles),
              removed: Array.from(removedStyles),
              moved: Array.from(movedStyles),
              updated: []
            });
          }
        }
        function handleMinorTreeMutations(_a) {
          var additions = _a.additions, moves = _a.moves, deletions = _a.deletions;
          var createdStyles = /* @__PURE__ */ new Set();
          var removedStyles = /* @__PURE__ */ new Set();
          var movedStyles = /* @__PURE__ */ new Set();
          additions.forEach(function(node) {
            return getManageableStyles(node).forEach(function(style) {
              return createdStyles.add(style);
            });
          });
          deletions.forEach(function(node) {
            return getManageableStyles(node).forEach(function(style) {
              return removedStyles.add(style);
            });
          });
          moves.forEach(function(node) {
            return getManageableStyles(node).forEach(function(style) {
              return movedStyles.add(style);
            });
          });
          handleStyleOperations({
            createdStyles,
            removedStyles,
            movedStyles
          });
          additions.forEach(function(n) {
            iterateShadowHosts(n, subscribeForShadowRootChanges);
            collectUndefinedElements(n);
          });
        }
        function handleHugeTreeMutations(root) {
          var styles = new Set(getManageableStyles(root));
          var createdStyles = /* @__PURE__ */ new Set();
          var removedStyles = /* @__PURE__ */ new Set();
          var movedStyles = /* @__PURE__ */ new Set();
          styles.forEach(function(s) {
            if (!prevStyles.has(s)) {
              createdStyles.add(s);
            }
          });
          prevStyles.forEach(function(s) {
            if (!styles.has(s)) {
              removedStyles.add(s);
            }
          });
          styles.forEach(function(s) {
            if (!createdStyles.has(s) && !removedStyles.has(s) && didStylePositionChange(s)) {
              movedStyles.add(s);
            }
          });
          handleStyleOperations({
            createdStyles,
            removedStyles,
            movedStyles
          });
          iterateShadowHosts(root, subscribeForShadowRootChanges);
          collectUndefinedElements(root);
        }
        function handleAttributeMutations(mutations) {
          var updatedStyles = /* @__PURE__ */ new Set();
          var removedStyles = /* @__PURE__ */ new Set();
          mutations.forEach(function(m) {
            var target = m.target;
            if (target.isConnected) {
              if (shouldManageStyle(target)) {
                updatedStyles.add(target);
              } else if (target instanceof HTMLLinkElement && target.disabled) {
                removedStyles.add(target);
              }
            }
          });
          if (updatedStyles.size + removedStyles.size > 0) {
            update({
              updated: Array.from(updatedStyles),
              created: [],
              removed: Array.from(removedStyles),
              moved: []
            });
          }
        }
        function observe(root) {
          var treeObserver = createOptimizedTreeObserver(root, {
            onMinorMutations: handleMinorTreeMutations,
            onHugeMutations: handleHugeTreeMutations
          });
          var attrObserver = new MutationObserver(handleAttributeMutations);
          attrObserver.observe(root, {
            attributes: true,
            attributeFilter: ["rel", "disabled", "media", "href"],
            subtree: true
          });
          observers.push(treeObserver, attrObserver);
          observedRoots.add(root);
        }
        function subscribeForShadowRootChanges(node) {
          var shadowRoot = node.shadowRoot;
          if (shadowRoot == null || observedRoots.has(shadowRoot)) {
            return;
          }
          observe(shadowRoot);
          shadowRootDiscovered(shadowRoot);
        }
        observe(document);
        iterateShadowHosts(
          document.documentElement,
          subscribeForShadowRootChanges
        );
        watchWhenCustomElementsDefined(function(hosts) {
          var newStyles = [];
          hosts.forEach(function(host) {
            return push(newStyles, getManageableStyles(host.shadowRoot));
          });
          update({ created: newStyles, updated: [], removed: [], moved: [] });
          hosts.forEach(function(host) {
            var shadowRoot = host.shadowRoot;
            if (shadowRoot == null) {
              return;
            }
            subscribeForShadowRootChanges(host);
            iterateShadowHosts(shadowRoot, subscribeForShadowRootChanges);
            collectUndefinedElements(shadowRoot);
          });
        });
        document.addEventListener("__darkreader__isDefined", handleIsDefined);
        collectUndefinedElements(document);
      }
      function resetObservers() {
        observers.forEach(function(o) {
          return o.disconnect();
        });
        observers.splice(0, observers.length);
        observedRoots = /* @__PURE__ */ new WeakSet();
      }
      function stopWatchingForStyleChanges() {
        resetObservers();
        unsubscribeFromDefineCustomElements();
      }
      function hexify(number) {
        return (number < 16 ? "0" : "") + number.toString(16);
      }
      function generateUID() {
        if ("randomUUID" in crypto) {
          var uuid = crypto.randomUUID();
          return uuid.substring(0, 8) + uuid.substring(9, 13) + uuid.substring(14, 18) + uuid.substring(19, 23) + uuid.substring(24);
        }
        return Array.from(crypto.getRandomValues(new Uint8Array(16))).map(function(x) {
          return hexify(x);
        }).join("");
      }
      var adoptedStyleOverrides = /* @__PURE__ */ new WeakMap();
      var overrideList = /* @__PURE__ */ new WeakSet();
      function createAdoptedStyleSheetOverride(node) {
        var cancelAsyncOperations = false;
        function injectSheet(sheet, override) {
          var newSheets = __spreadArray(
            [],
            __read(node.adoptedStyleSheets),
            false
          );
          var sheetIndex = newSheets.indexOf(sheet);
          var existingIndex = newSheets.indexOf(override);
          if (sheetIndex === existingIndex - 1) {
            return;
          }
          if (existingIndex >= 0) {
            newSheets.splice(existingIndex, 1);
          }
          newSheets.splice(sheetIndex + 1, 0, override);
          node.adoptedStyleSheets = newSheets;
        }
        function destroy() {
          cancelAsyncOperations = true;
          var newSheets = __spreadArray(
            [],
            __read(node.adoptedStyleSheets),
            false
          );
          node.adoptedStyleSheets.forEach(function(adoptedStyleSheet) {
            if (overrideList.has(adoptedStyleSheet)) {
              var existingIndex = newSheets.indexOf(adoptedStyleSheet);
              if (existingIndex >= 0) {
                newSheets.splice(existingIndex, 1);
              }
              adoptedStyleOverrides.delete(adoptedStyleSheet);
              overrideList.delete(adoptedStyleSheet);
            }
          });
          node.adoptedStyleSheets = newSheets;
        }
        function render(theme, ignoreImageAnalysis) {
          node.adoptedStyleSheets.forEach(function(sheet) {
            if (overrideList.has(sheet)) {
              return;
            }
            var rules = sheet.rules;
            var override = new CSSStyleSheet();
            function prepareOverridesSheet() {
              for (var i = override.cssRules.length - 1; i >= 0; i--) {
                override.deleteRule(i);
              }
              injectSheet(sheet, override);
              adoptedStyleOverrides.set(sheet, override);
              overrideList.add(override);
              return override;
            }
            var sheetModifier = createStyleSheetModifier();
            sheetModifier.modifySheet({
              prepareSheet: prepareOverridesSheet,
              sourceCSSRules: rules,
              theme,
              ignoreImageAnalysis,
              force: false,
              isAsyncCancelled: function() {
                return cancelAsyncOperations;
              }
            });
          });
        }
        return {
          render,
          destroy
        };
      }
      function injectProxy(enableStyleSheetsProxy) {
        document.dispatchEvent(
          new CustomEvent("__darkreader__inlineScriptsAllowed")
        );
        var addRuleDescriptor = Object.getOwnPropertyDescriptor(
          CSSStyleSheet.prototype,
          "addRule"
        );
        var insertRuleDescriptor = Object.getOwnPropertyDescriptor(
          CSSStyleSheet.prototype,
          "insertRule"
        );
        var deleteRuleDescriptor = Object.getOwnPropertyDescriptor(
          CSSStyleSheet.prototype,
          "deleteRule"
        );
        var removeRuleDescriptor = Object.getOwnPropertyDescriptor(
          CSSStyleSheet.prototype,
          "removeRule"
        );
        var documentStyleSheetsDescriptor = enableStyleSheetsProxy ? Object.getOwnPropertyDescriptor(Document.prototype, "styleSheets") : null;
        var shouldWrapHTMLElement = [
          "baidu.com",
          "baike.baidu.com",
          "ditu.baidu.com",
          "map.baidu.com",
          "maps.baidu.com",
          "haokan.baidu.com",
          "pan.baidu.com",
          "passport.baidu.com",
          "tieba.baidu.com",
          "www.baidu.com"
        ].includes(location.hostname);
        var getElementsByTagNameDescriptor = shouldWrapHTMLElement ? Object.getOwnPropertyDescriptor(
          Element.prototype,
          "getElementsByTagName"
        ) : null;
        var cleanUp = function() {
          Object.defineProperty(
            CSSStyleSheet.prototype,
            "addRule",
            addRuleDescriptor
          );
          Object.defineProperty(
            CSSStyleSheet.prototype,
            "insertRule",
            insertRuleDescriptor
          );
          Object.defineProperty(
            CSSStyleSheet.prototype,
            "deleteRule",
            deleteRuleDescriptor
          );
          Object.defineProperty(
            CSSStyleSheet.prototype,
            "removeRule",
            removeRuleDescriptor
          );
          document.removeEventListener("__darkreader__cleanUp", cleanUp);
          document.removeEventListener(
            "__darkreader__addUndefinedResolver",
            addUndefinedResolver
          );
          if (enableStyleSheetsProxy) {
            Object.defineProperty(
              Document.prototype,
              "styleSheets",
              documentStyleSheetsDescriptor
            );
          }
          if (shouldWrapHTMLElement) {
            Object.defineProperty(
              Element.prototype,
              "getElementsByTagName",
              getElementsByTagNameDescriptor
            );
          }
        };
        var addUndefinedResolver = function(e) {
          customElements.whenDefined(e.detail.tag).then(function() {
            document.dispatchEvent(
              new CustomEvent("__darkreader__isDefined", {
                detail: { tag: e.detail.tag }
              })
            );
          });
        };
        document.addEventListener("__darkreader__cleanUp", cleanUp);
        document.addEventListener(
          "__darkreader__addUndefinedResolver",
          addUndefinedResolver
        );
        var updateSheetEvent = new Event("__darkreader__updateSheet");
        function proxyAddRule(selector, style, index) {
          addRuleDescriptor.value.call(this, selector, style, index);
          if (this.ownerNode && !this.ownerNode.classList.contains("darkreader")) {
            this.ownerNode.dispatchEvent(updateSheetEvent);
          }
          return -1;
        }
        function proxyInsertRule(rule, index) {
          var returnValue = insertRuleDescriptor.value.call(
            this,
            rule,
            index
          );
          if (this.ownerNode && !this.ownerNode.classList.contains("darkreader")) {
            this.ownerNode.dispatchEvent(updateSheetEvent);
          }
          return returnValue;
        }
        function proxyDeleteRule(index) {
          deleteRuleDescriptor.value.call(this, index);
          if (this.ownerNode && !this.ownerNode.classList.contains("darkreader")) {
            this.ownerNode.dispatchEvent(updateSheetEvent);
          }
        }
        function proxyRemoveRule(index) {
          removeRuleDescriptor.value.call(this, index);
          if (this.ownerNode && !this.ownerNode.classList.contains("darkreader")) {
            this.ownerNode.dispatchEvent(updateSheetEvent);
          }
        }
        function proxyDocumentStyleSheets() {
          var _this = this;
          var getCurrentValue = function() {
            var docSheets = documentStyleSheetsDescriptor.get.call(_this);
            var filteredSheets = __spreadArray(
              [],
              __read(docSheets),
              false
            ).filter(function(styleSheet) {
              return !styleSheet.ownerNode.classList.contains(
                "darkreader"
              );
            });
            filteredSheets.item = function(item) {
              return filteredSheets[item];
            };
            return Object.setPrototypeOf(
              filteredSheets,
              StyleSheetList.prototype
            );
          };
          var elements = getCurrentValue();
          var styleSheetListBehavior = {
            get: function(_, property) {
              return getCurrentValue()[property];
            }
          };
          elements = new Proxy(elements, styleSheetListBehavior);
          return elements;
        }
        function proxyGetElementsByTagName(tagName) {
          var _this = this;
          if (tagName !== "style") {
            return getElementsByTagNameDescriptor.value.call(this, tagName);
          }
          var getCurrentElementValue = function() {
            var elements2 = getElementsByTagNameDescriptor.value.call(
              _this,
              tagName
            );
            return Object.setPrototypeOf(
              __spreadArray([], __read(elements2), false).filter(function(element) {
                return !element.classList.contains("darkreader");
              }),
              NodeList.prototype
            );
          };
          var elements = getCurrentElementValue();
          var nodeListBehavior = {
            get: function(_, property) {
              return getCurrentElementValue()[Number(property) || property];
            }
          };
          elements = new Proxy(elements, nodeListBehavior);
          return elements;
        }
        Object.defineProperty(
          CSSStyleSheet.prototype,
          "addRule",
          Object.assign({}, addRuleDescriptor, { value: proxyAddRule })
        );
        Object.defineProperty(
          CSSStyleSheet.prototype,
          "insertRule",
          Object.assign({}, insertRuleDescriptor, { value: proxyInsertRule })
        );
        Object.defineProperty(
          CSSStyleSheet.prototype,
          "deleteRule",
          Object.assign({}, deleteRuleDescriptor, { value: proxyDeleteRule })
        );
        Object.defineProperty(
          CSSStyleSheet.prototype,
          "removeRule",
          Object.assign({}, removeRuleDescriptor, { value: proxyRemoveRule })
        );
        if (enableStyleSheetsProxy) {
          Object.defineProperty(
            Document.prototype,
            "styleSheets",
            Object.assign({}, documentStyleSheetsDescriptor, {
              get: proxyDocumentStyleSheets
            })
          );
        }
        if (shouldWrapHTMLElement) {
          Object.defineProperty(
            Element.prototype,
            "getElementsByTagName",
            Object.assign({}, getElementsByTagNameDescriptor, {
              value: proxyGetElementsByTagName
            })
          );
        }
      }
      var INSTANCE_ID = generateUID();
      var styleManagers = /* @__PURE__ */ new Map();
      var adoptedStyleManagers = [];
      var filter = null;
      var fixes = null;
      var isIFrame$1 = null;
      var ignoredImageAnalysisSelectors = null;
      var ignoredInlineSelectors = null;
      function createOrUpdateStyle(className, root) {
        if (root === void 0) {
          root = document.head || document;
        }
        var element = root.querySelector(".".concat(className));
        if (!element) {
          element = document.createElement("style");
          element.classList.add("darkreader");
          element.classList.add(className);
          element.media = "screen";
          element.textContent = "";
        }
        return element;
      }
      function createOrUpdateScript(className, root) {
        if (root === void 0) {
          root = document.head || document;
        }
        var element = root.querySelector(".".concat(className));
        if (!element) {
          element = document.createElement("script");
          element.classList.add("darkreader");
          element.classList.add(className);
        }
        return element;
      }
      var nodePositionWatchers = /* @__PURE__ */ new Map();
      function setupNodePositionWatcher(node, alias) {
        nodePositionWatchers.has(alias) && nodePositionWatchers.get(alias).stop();
        nodePositionWatchers.set(alias, watchForNodePosition(node, "parent"));
      }
      function stopStylePositionWatchers() {
        forEach(nodePositionWatchers.values(), function(watcher) {
          return watcher.stop();
        });
        nodePositionWatchers.clear();
      }
      function createStaticStyleOverrides() {
        var fallbackStyle = createOrUpdateStyle(
          "darkreader--fallback",
          document
        );
        fallbackStyle.textContent = getModifiedFallbackStyle(filter, {
          strict: true
        });
        document.head.insertBefore(fallbackStyle, document.head.firstChild);
        setupNodePositionWatcher(fallbackStyle, "fallback");
        var userAgentStyle = createOrUpdateStyle("darkreader--user-agent");
        userAgentStyle.textContent = getModifiedUserAgentStyle(
          filter,
          isIFrame$1,
          filter.styleSystemControls
        );
        document.head.insertBefore(userAgentStyle, fallbackStyle.nextSibling);
        setupNodePositionWatcher(userAgentStyle, "user-agent");
        var textStyle = createOrUpdateStyle("darkreader--text");
        if (filter.useFont || filter.textStroke > 0) {
          textStyle.textContent = createTextStyle(filter);
        } else {
          textStyle.textContent = "";
        }
        document.head.insertBefore(textStyle, fallbackStyle.nextSibling);
        setupNodePositionWatcher(textStyle, "text");
        var invertStyle = createOrUpdateStyle("darkreader--invert");
        if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {
          invertStyle.textContent = [
            "".concat(fixes.invert.join(", "), " {"),
            "    filter: ".concat(
              getCSSFilterValue(
                __assign(__assign({}, filter), {
                  contrast: filter.mode === 0 ? filter.contrast : clamp(filter.contrast - 10, 0, 100)
                })
              ),
              " !important;"
            ),
            "}"
          ].join("\n");
        } else {
          invertStyle.textContent = "";
        }
        document.head.insertBefore(invertStyle, textStyle.nextSibling);
        setupNodePositionWatcher(invertStyle, "invert");
        var inlineStyle = createOrUpdateStyle("darkreader--inline");
        inlineStyle.textContent = getInlineOverrideStyle();
        document.head.insertBefore(inlineStyle, invertStyle.nextSibling);
        setupNodePositionWatcher(inlineStyle, "inline");
        var overrideStyle = createOrUpdateStyle("darkreader--override");
        overrideStyle.textContent = fixes && fixes.css ? replaceCSSTemplates(fixes.css) : "";
        document.head.appendChild(overrideStyle);
        setupNodePositionWatcher(overrideStyle, "override");
        var variableStyle = createOrUpdateStyle("darkreader--variables");
        var selectionColors = getSelectionColor(filter);
        var darkSchemeBackgroundColor = filter.darkSchemeBackgroundColor, darkSchemeTextColor = filter.darkSchemeTextColor, lightSchemeBackgroundColor = filter.lightSchemeBackgroundColor, lightSchemeTextColor = filter.lightSchemeTextColor, mode = filter.mode;
        var schemeBackgroundColor = mode === 0 ? lightSchemeBackgroundColor : darkSchemeBackgroundColor;
        var schemeTextColor = mode === 0 ? lightSchemeTextColor : darkSchemeTextColor;
        schemeBackgroundColor = modifyBackgroundColor(
          parseColorWithCache(schemeBackgroundColor),
          filter
        );
        schemeTextColor = modifyForegroundColor(
          parseColorWithCache(schemeTextColor),
          filter
        );
        variableStyle.textContent = [
          ":root {",
          "   --darkreader-neutral-background: ".concat(
            schemeBackgroundColor,
            ";"
          ),
          "   --darkreader-neutral-text: ".concat(schemeTextColor, ";"),
          "   --darkreader-selection-background: ".concat(
            selectionColors.backgroundColorSelection,
            ";"
          ),
          "   --darkreader-selection-text: ".concat(
            selectionColors.foregroundColorSelection,
            ";"
          ),
          "}"
        ].join("\n");
        document.head.insertBefore(variableStyle, inlineStyle.nextSibling);
        setupNodePositionWatcher(variableStyle, "variables");
        var rootVarsStyle = createOrUpdateStyle("darkreader--root-vars");
        document.head.insertBefore(rootVarsStyle, variableStyle.nextSibling);
        var injectProxyArg = !(fixes && fixes.disableStyleSheetsProxy);
        {
          var proxyScript = createOrUpdateScript("darkreader--proxy");
          proxyScript.append(
            "(".concat(injectProxy, ")(").concat(injectProxyArg, ")")
          );
          document.head.insertBefore(proxyScript, rootVarsStyle.nextSibling);
          proxyScript.remove();
        }
      }
      var shadowRootsWithOverrides = /* @__PURE__ */ new Set();
      function createShadowStaticStyleOverrides(root) {
        var inlineStyle = createOrUpdateStyle("darkreader--inline", root);
        inlineStyle.textContent = getInlineOverrideStyle();
        root.insertBefore(inlineStyle, root.firstChild);
        var overrideStyle = createOrUpdateStyle("darkreader--override", root);
        overrideStyle.textContent = fixes && fixes.css ? replaceCSSTemplates(fixes.css) : "";
        root.insertBefore(overrideStyle, inlineStyle.nextSibling);
        var invertStyle = createOrUpdateStyle("darkreader--invert", root);
        if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {
          invertStyle.textContent = [
            "".concat(fixes.invert.join(", "), " {"),
            "    filter: ".concat(
              getCSSFilterValue(
                __assign(__assign({}, filter), {
                  contrast: filter.mode === 0 ? filter.contrast : clamp(filter.contrast - 10, 0, 100)
                })
              ),
              " !important;"
            ),
            "}"
          ].join("\n");
        } else {
          invertStyle.textContent = "";
        }
        root.insertBefore(invertStyle, overrideStyle.nextSibling);
        shadowRootsWithOverrides.add(root);
      }
      function replaceCSSTemplates($cssText) {
        return $cssText.replace(/\${(.+?)}/g, function(_, $color) {
          var color = parseColorWithCache($color);
          if (color) {
            return modifyColor(color, filter);
          }
          return $color;
        });
      }
      function cleanFallbackStyle() {
        var fallback = document.querySelector(".darkreader--fallback");
        if (fallback) {
          fallback.textContent = "";
        }
      }
      function createDynamicStyleOverrides() {
        cancelRendering();
        var allStyles = getManageableStyles(document);
        var newManagers = allStyles.filter(function(style) {
          return !styleManagers.has(style);
        }).map(function(style) {
          return createManager(style);
        });
        newManagers.map(function(manager) {
          return manager.details({ secondRound: false });
        }).filter(function(detail) {
          return detail && detail.rules.length > 0;
        }).forEach(function(detail) {
          variablesStore.addRulesForMatching(detail.rules);
        });
        variablesStore.matchVariablesAndDependants();
        variablesStore.setOnRootVariableChange(function() {
          variablesStore.putRootVars(
            document.head.querySelector(".darkreader--root-vars"),
            filter
          );
        });
        variablesStore.putRootVars(
          document.head.querySelector(".darkreader--root-vars"),
          filter
        );
        styleManagers.forEach(function(manager) {
          return manager.render(filter, ignoredImageAnalysisSelectors);
        });
        if (loadingStyles.size === 0) {
          cleanFallbackStyle();
        }
        newManagers.forEach(function(manager) {
          return manager.watch();
        });
        var inlineStyleElements = toArray(
          document.querySelectorAll(INLINE_STYLE_SELECTOR)
        );
        iterateShadowHosts(document.documentElement, function(host) {
          createShadowStaticStyleOverrides(host.shadowRoot);
          var elements = host.shadowRoot.querySelectorAll(
            INLINE_STYLE_SELECTOR
          );
          if (elements.length > 0) {
            push(inlineStyleElements, elements);
          }
        });
        inlineStyleElements.forEach(function(el) {
          return overrideInlineStyle(
            el,
            filter,
            ignoredInlineSelectors,
            ignoredImageAnalysisSelectors
          );
        });
        handleAdoptedStyleSheets(document);
      }
      var loadingStylesCounter = 0;
      var loadingStyles = /* @__PURE__ */ new Set();
      function createManager(element) {
        var loadingStyleId = ++loadingStylesCounter;
        function loadingStart() {
          if (!isDOMReady() || !didDocumentShowUp) {
            loadingStyles.add(loadingStyleId);
            logInfo(
              "Current amount of styles loading: ".concat(
                loadingStyles.size
              )
            );
            var fallbackStyle = document.querySelector(
              ".darkreader--fallback"
            );
            if (!fallbackStyle.textContent) {
              fallbackStyle.textContent = getModifiedFallbackStyle(
                filter,
                { strict: false }
              );
            }
          }
        }
        function loadingEnd() {
          loadingStyles.delete(loadingStyleId);
          logInfo(
            "Removed loadingStyle ".concat(loadingStyleId, ", now awaiting: ").concat(loadingStyles.size)
          );
          if (loadingStyles.size === 0 && isDOMReady()) {
            cleanFallbackStyle();
          }
        }
        function update() {
          var details = manager.details({ secondRound: true });
          if (!details) {
            return;
          }
          variablesStore.addRulesForMatching(details.rules);
          variablesStore.matchVariablesAndDependants();
          manager.render(filter, ignoredImageAnalysisSelectors);
        }
        var manager = manageStyle(element, {
          update,
          loadingStart,
          loadingEnd
        });
        styleManagers.set(element, manager);
        return manager;
      }
      function removeManager(element) {
        var manager = styleManagers.get(element);
        if (manager) {
          manager.destroy();
          styleManagers.delete(element);
        }
      }
      var throttledRenderAllStyles = throttle(function(callback) {
        styleManagers.forEach(function(manager) {
          return manager.render(filter, ignoredImageAnalysisSelectors);
        });
        adoptedStyleManagers.forEach(function(manager) {
          return manager.render(filter, ignoredImageAnalysisSelectors);
        });
        callback && callback();
      });
      var cancelRendering = function() {
        throttledRenderAllStyles.cancel();
      };
      function onDOMReady() {
        if (loadingStyles.size === 0) {
          cleanFallbackStyle();
          return;
        }
      }
      var documentVisibilityListener = null;
      var didDocumentShowUp = !document.hidden;
      function watchForDocumentVisibility(callback) {
        var alreadyWatching = Boolean(documentVisibilityListener);
        documentVisibilityListener = function() {
          if (!document.hidden) {
            stopWatchingForDocumentVisibility();
            callback();
            didDocumentShowUp = true;
          }
        };
        if (!alreadyWatching) {
          document.addEventListener(
            "visibilitychange",
            documentVisibilityListener
          );
        }
      }
      function stopWatchingForDocumentVisibility() {
        document.removeEventListener(
          "visibilitychange",
          documentVisibilityListener
        );
        documentVisibilityListener = null;
      }
      function createThemeAndWatchForUpdates() {
        createStaticStyleOverrides();
        function runDynamicStyle() {
          createDynamicStyleOverrides();
          watchForUpdates();
        }
        if (document.hidden && !filter.immediateModify) {
          watchForDocumentVisibility(runDynamicStyle);
        } else {
          runDynamicStyle();
        }
        changeMetaThemeColorWhenAvailable(filter);
      }
      function handleAdoptedStyleSheets(node) {
        try {
          if (Array.isArray(node.adoptedStyleSheets)) {
            if (node.adoptedStyleSheets.length > 0) {
              var newManger = createAdoptedStyleSheetOverride(node);
              adoptedStyleManagers.push(newManger);
              newManger.render(filter, ignoredImageAnalysisSelectors);
            }
          }
        } catch (err) {
        }
      }
      function watchForUpdates() {
        var managedStyles = Array.from(styleManagers.keys());
        watchForStyleChanges(
          managedStyles,
          function(_a) {
            var created = _a.created, updated = _a.updated, removed = _a.removed, moved = _a.moved;
            var stylesToRemove = removed;
            var stylesToManage = created.concat(updated).concat(moved).filter(function(style) {
              return !styleManagers.has(style);
            });
            var stylesToRestore = moved.filter(function(style) {
              return styleManagers.has(style);
            });
            stylesToRemove.forEach(function(style) {
              return removeManager(style);
            });
            var newManagers = stylesToManage.map(function(style) {
              return createManager(style);
            });
            newManagers.map(function(manager) {
              return manager.details({ secondRound: false });
            }).filter(function(detail) {
              return detail && detail.rules.length > 0;
            }).forEach(function(detail) {
              variablesStore.addRulesForMatching(detail.rules);
            });
            variablesStore.matchVariablesAndDependants();
            newManagers.forEach(function(manager) {
              return manager.render(
                filter,
                ignoredImageAnalysisSelectors
              );
            });
            newManagers.forEach(function(manager) {
              return manager.watch();
            });
            stylesToRestore.forEach(function(style) {
              return styleManagers.get(style).restore();
            });
          },
          function(shadowRoot) {
            createShadowStaticStyleOverrides(shadowRoot);
            handleAdoptedStyleSheets(shadowRoot);
          }
        );
        watchForInlineStyles(
          function(element) {
            overrideInlineStyle(
              element,
              filter,
              ignoredInlineSelectors,
              ignoredImageAnalysisSelectors
            );
            if (element === document.documentElement) {
              var styleAttr = element.getAttribute("style") || "";
              if (styleAttr.includes("--")) {
                variablesStore.matchVariablesAndDependants();
                variablesStore.putRootVars(
                  document.head.querySelector(
                    ".darkreader--root-vars"
                  ),
                  filter
                );
              }
            }
          },
          function(root) {
            createShadowStaticStyleOverrides(root);
            var inlineStyleElements = root.querySelectorAll(
              INLINE_STYLE_SELECTOR
            );
            if (inlineStyleElements.length > 0) {
              forEach(inlineStyleElements, function(el) {
                return overrideInlineStyle(
                  el,
                  filter,
                  ignoredInlineSelectors,
                  ignoredImageAnalysisSelectors
                );
              });
            }
          }
        );
        addDOMReadyListener(onDOMReady);
      }
      function stopWatchingForUpdates() {
        styleManagers.forEach(function(manager) {
          return manager.pause();
        });
        stopStylePositionWatchers();
        stopWatchingForStyleChanges();
        stopWatchingForInlineStyles();
        removeDOMReadyListener(onDOMReady);
        cleanReadyStateCompleteListeners();
      }
      var metaObserver;
      function addMetaListener() {
        metaObserver = new MutationObserver(function() {
          if (document.querySelector('meta[name="darkreader-lock"]')) {
            metaObserver.disconnect();
            removeDynamicTheme();
          }
        });
        metaObserver.observe(document.head, { childList: true, subtree: true });
      }
      function createDarkReaderInstanceMarker() {
        var metaElement = document.createElement("meta");
        metaElement.name = "darkreader";
        metaElement.content = INSTANCE_ID;
        document.head.appendChild(metaElement);
      }
      function isAnotherDarkReaderInstanceActive() {
        if (document.querySelector('meta[name="darkreader-lock"]')) {
          return true;
        }
        var meta = document.querySelector('meta[name="darkreader"]');
        if (meta) {
          if (meta.content !== INSTANCE_ID) {
            return true;
          }
          return false;
        }
        createDarkReaderInstanceMarker();
        addMetaListener();
        return false;
      }
      function createOrUpdateDynamicTheme(filterConfig, dynamicThemeFixes, iframe) {
        filter = filterConfig;
        fixes = dynamicThemeFixes;
        if (fixes) {
          ignoredImageAnalysisSelectors = Array.isArray(
            fixes.ignoreImageAnalysis
          ) ? fixes.ignoreImageAnalysis : [];
          ignoredInlineSelectors = Array.isArray(fixes.ignoreInlineStyle) ? fixes.ignoreInlineStyle : [];
        } else {
          ignoredImageAnalysisSelectors = [];
          ignoredInlineSelectors = [];
        }
        if (filter.immediateModify) {
          setIsDOMReady(function() {
            return true;
          });
        }
        isIFrame$1 = iframe;
        if (document.head) {
          if (isAnotherDarkReaderInstanceActive()) {
            return;
          }
          document.documentElement.setAttribute(
            "data-darkreader-mode",
            "dynamic"
          );
          document.documentElement.setAttribute(
            "data-darkreader-scheme",
            filter.mode ? "dark" : "dimmed"
          );
          createThemeAndWatchForUpdates();
        } else {
          if (!isFirefox) {
            var fallbackStyle = createOrUpdateStyle("darkreader--fallback");
            document.documentElement.appendChild(fallbackStyle);
            fallbackStyle.textContent = getModifiedFallbackStyle(filter, {
              strict: true
            });
          }
          var headObserver_1 = new MutationObserver(function() {
            if (document.head) {
              headObserver_1.disconnect();
              if (isAnotherDarkReaderInstanceActive()) {
                removeDynamicTheme();
                return;
              }
              createThemeAndWatchForUpdates();
            }
          });
          headObserver_1.observe(document, { childList: true, subtree: true });
        }
      }
      function removeProxy() {
        document.dispatchEvent(new CustomEvent("__darkreader__cleanUp"));
        removeNode(document.head.querySelector(".darkreader--proxy"));
      }
      function removeDynamicTheme() {
        document.documentElement.removeAttribute("data-darkreader-mode");
        document.documentElement.removeAttribute("data-darkreader-scheme");
        cleanDynamicThemeCache();
        removeNode(document.querySelector(".darkreader--fallback"));
        if (document.head) {
          restoreMetaThemeColor();
          removeNode(document.head.querySelector(".darkreader--user-agent"));
          removeNode(document.head.querySelector(".darkreader--text"));
          removeNode(document.head.querySelector(".darkreader--invert"));
          removeNode(document.head.querySelector(".darkreader--inline"));
          removeNode(document.head.querySelector(".darkreader--override"));
          removeNode(document.head.querySelector(".darkreader--variables"));
          removeNode(document.head.querySelector(".darkreader--root-vars"));
          removeNode(document.head.querySelector('meta[name="darkreader"]'));
          removeProxy();
        }
        shadowRootsWithOverrides.forEach(function(root) {
          removeNode(root.querySelector(".darkreader--inline"));
          removeNode(root.querySelector(".darkreader--override"));
        });
        shadowRootsWithOverrides.clear();
        forEach(styleManagers.keys(), function(el) {
          return removeManager(el);
        });
        loadingStyles.clear();
        cleanLoadingLinks();
        forEach(document.querySelectorAll(".darkreader"), removeNode);
        adoptedStyleManagers.forEach(function(manager) {
          manager.destroy();
        });
        adoptedStyleManagers.splice(0);
        metaObserver && metaObserver.disconnect();
      }
      function cleanDynamicThemeCache() {
        variablesStore.clear();
        parsedURLCache.clear();
        stopWatchingForDocumentVisibility();
        cancelRendering();
        stopWatchingForUpdates();
        cleanModificationCache();
        clearColorCache();
      }
      var blobRegex = /url\(\"(blob\:.*?)\"\)/g;
      function replaceBlobs(text) {
        return __awaiter(this, void 0, void 0, function() {
          var promises, data;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                promises = [];
                getMatches(blobRegex, text, 1).forEach(function(url) {
                  var promise = loadAsDataURL(url);
                  promises.push(promise);
                });
                return [4, Promise.all(promises)];
              case 1:
                data = _a.sent();
                return [
                  2,
                  text.replace(blobRegex, function() {
                    return 'url("'.concat(data.shift(), '")');
                  })
                ];
            }
          });
        });
      }
      var banner = '/*\n                        _______\n                       /       \\\n                      .==.    .==.\n                     ((  ))==((  ))\n                    / "=="    "=="\\\n                   /____|| || ||___\\\n       ________     ____    ________  ___    ___\n       |  ___  \\   /    \\   |  ___  \\ |  |  /  /\n       |  |  \\  \\ /  /\\  \\  |  |  \\  \\|  |_/  /\n       |  |   )  /  /__\\  \\ |  |__/  /|  ___  \\\n       |  |__/  /  ______  \\|  ____  \\|  |  \\  \\\n_______|_______/__/ ____ \\__\\__|___\\__\\__|___\\__\\____\n|  ___  \\ |  ____/ /    \\   |  ___  \\ |  ____|  ___  \\\n|  |  \\  \\|  |___ /  /\\  \\  |  |  \\  \\|  |___|  |  \\  \\\n|  |__/  /|  ____/  /__\\  \\ |  |   )  |  ____|  |__/  /\n|  ____  \\|  |__/  ______  \\|  |__/  /|  |___|  ____  \\\n|__|   \\__\\____/__/      \\__\\_______/ |______|__|   \\__\\\n                https://darkreader.org\n*/\n\n/*! Dark reader generated CSS | Licensed under MIT https://github.com/darkreader/darkreader/blob/main/LICENSE */\n';
      function collectCSS() {
        return __awaiter(this, void 0, void 0, function() {
          function addStaticCSS(selector, comment) {
            var staticStyle = document.querySelector(selector);
            if (staticStyle && staticStyle.textContent) {
              css.push("/* ".concat(comment, " */"));
              css.push(staticStyle.textContent);
              css.push("");
            }
          }
          var css, modifiedCSS, formattedCSS, _a, _b;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                css = [banner];
                addStaticCSS(".darkreader--fallback", "Fallback Style");
                addStaticCSS(
                  ".darkreader--user-agent",
                  "User-Agent Style"
                );
                addStaticCSS(".darkreader--text", "Text Style");
                addStaticCSS(".darkreader--invert", "Invert Style");
                addStaticCSS(
                  ".darkreader--variables",
                  "Variables Style"
                );
                modifiedCSS = [];
                document.querySelectorAll(".darkreader--sync").forEach(function(element) {
                  forEach(
                    element.sheet.cssRules,
                    function(rule) {
                      rule && rule.cssText && modifiedCSS.push(rule.cssText);
                    }
                  );
                });
                if (!modifiedCSS.length)
                  return [3, 2];
                formattedCSS = formatCSS(modifiedCSS.join("\n"));
                css.push("/* Modified CSS */");
                _b = (_a = css).push;
                return [4, replaceBlobs(formattedCSS)];
              case 1:
                _b.apply(_a, [_c.sent()]);
                css.push("");
                _c.label = 2;
              case 2:
                addStaticCSS(".darkreader--override", "Override Style");
                return [2, css.join("\n")];
            }
          });
        });
      }
      var isDarkReaderEnabled = false;
      var isIFrame = function() {
        try {
          return window.self !== window.top;
        } catch (err) {
          console.warn(err);
          return true;
        }
      }();
      function enable2(themeOptions, fixes2) {
        if (themeOptions === void 0) {
          themeOptions = {};
        }
        if (fixes2 === void 0) {
          fixes2 = null;
        }
        var theme = __assign(__assign({}, DEFAULT_THEME), themeOptions);
        if (theme.engine !== ThemeEngine.dynamicTheme) {
          throw new Error("Theme engine is not supported.");
        }
        createOrUpdateDynamicTheme(theme, fixes2, isIFrame);
        isDarkReaderEnabled = true;
      }
      function isEnabled() {
        return isDarkReaderEnabled;
      }
      function disable2() {
        removeDynamicTheme();
        isDarkReaderEnabled = false;
      }
      var darkScheme = matchMedia("(prefers-color-scheme: dark)");
      var store = {
        themeOptions: null,
        fixes: null
      };
      function handleColorScheme() {
        if (darkScheme.matches) {
          enable2(store.themeOptions, store.fixes);
        } else {
          disable2();
        }
      }
      function auto(themeOptions, fixes2) {
        if (themeOptions === void 0) {
          themeOptions = {};
        }
        if (fixes2 === void 0) {
          fixes2 = null;
        }
        if (themeOptions) {
          store = { themeOptions, fixes: fixes2 };
          handleColorScheme();
          if (isMatchMediaChangeEventListenerSupported) {
            darkScheme.addEventListener("change", handleColorScheme);
          } else {
            darkScheme.addListener(handleColorScheme);
          }
        } else {
          if (isMatchMediaChangeEventListenerSupported) {
            darkScheme.removeEventListener("change", handleColorScheme);
          } else {
            darkScheme.removeListener(handleColorScheme);
          }
          disable2();
        }
      }
      function exportGeneratedCSS2() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, collectCSS()];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      }
      var setFetchMethod2 = setFetchMethod$1;
      exports2.auto = auto;
      exports2.disable = disable2;
      exports2.enable = enable2;
      exports2.exportGeneratedCSS = exportGeneratedCSS2;
      exports2.isEnabled = isEnabled;
      exports2.setFetchMethod = setFetchMethod2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location2, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location2 + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location2, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location2, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location2, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location2, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location2, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/react-switch/dist/react-switch.dev.js
var require_react_switch_dev = __commonJS({
  "node_modules/react-switch/dist/react-switch.dev.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var React2 = require_react();
    var PropTypes = require_prop_types();
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    var uncheckedIcon = React2.createElement("svg", {
      viewBox: "-2 -5 14 20",
      height: "100%",
      width: "100%",
      style: {
        position: "absolute",
        top: 0
      }
    }, React2.createElement("path", {
      d: "M9.9 2.12L7.78 0 4.95 2.828 2.12 0 0 2.12l2.83 2.83L0 7.776 2.123 9.9 4.95 7.07 7.78 9.9 9.9 7.776 7.072 4.95 9.9 2.12",
      fill: "#fff",
      fillRule: "evenodd"
    }));
    var checkedIcon = React2.createElement("svg", {
      height: "100%",
      width: "100%",
      viewBox: "-2 -5 17 21",
      style: {
        position: "absolute",
        top: 0
      }
    }, React2.createElement("path", {
      d: "M11.264 0L5.26 6.004 2.103 2.847 0 4.95l5.26 5.26 8.108-8.107L11.264 0",
      fill: "#fff",
      fillRule: "evenodd"
    }));
    function createBackgroundColor(pos, checkedPos, uncheckedPos, offColor, onColor) {
      var relativePos = (pos - uncheckedPos) / (checkedPos - uncheckedPos);
      if (relativePos === 0) {
        return offColor;
      }
      if (relativePos === 1) {
        return onColor;
      }
      var newColor = "#";
      for (var i = 1; i < 6; i += 2) {
        var offComponent = parseInt(offColor.substr(i, 2), 16);
        var onComponent = parseInt(onColor.substr(i, 2), 16);
        var weightedValue = Math.round((1 - relativePos) * offComponent + relativePos * onComponent);
        var newComponent = weightedValue.toString(16);
        if (newComponent.length === 1) {
          newComponent = "0" + newComponent;
        }
        newColor += newComponent;
      }
      return newColor;
    }
    function convertShorthandColor(color) {
      if (color.length === 7) {
        return color;
      }
      var sixDigitColor = "#";
      for (var i = 1; i < 4; i += 1) {
        sixDigitColor += color[i] + color[i];
      }
      return sixDigitColor;
    }
    function getBackgroundColor(pos, checkedPos, uncheckedPos, offColor, onColor) {
      var sixDigitOffColor = convertShorthandColor(offColor);
      var sixDigitOnColor = convertShorthandColor(onColor);
      return createBackgroundColor(pos, checkedPos, uncheckedPos, sixDigitOffColor, sixDigitOnColor);
    }
    var hexColorPropType = function(props, propName, componentName) {
      var prop = props[propName];
      if (typeof prop !== "string" || prop[0] !== "#" || prop.length !== 4 && prop.length !== 7) {
        return new Error("Invalid prop '" + propName + "' supplied to '" + componentName + "'. '" + propName + "' has to be either a 3-digit or 6-digit hex-color string. Valid examples: '#abc', '#123456'");
      }
      return null;
    };
    function objectWithoutProperties(obj, exclude) {
      var target = {};
      for (var k in obj)
        if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1)
          target[k] = obj[k];
      return target;
    }
    var ReactSwitch2 = function(Component) {
      function ReactSwitch3(props) {
        Component.call(this, props);
        var height = props.height;
        var width = props.width;
        var handleDiameter = props.handleDiameter;
        var checked = props.checked;
        this.$handleDiameter = handleDiameter || height - 2;
        this.$checkedPos = Math.max(width - height, width - (height + this.$handleDiameter) / 2);
        this.$uncheckedPos = Math.max(0, (height - this.$handleDiameter) / 2);
        this.state = {
          $pos: checked ? this.$checkedPos : this.$uncheckedPos
        };
        this.$lastDragAt = 0;
        this.$lastKeyUpAt = 0;
        this.$onMouseDown = this.$onMouseDown.bind(this);
        this.$onMouseMove = this.$onMouseMove.bind(this);
        this.$onMouseUp = this.$onMouseUp.bind(this);
        this.$onTouchStart = this.$onTouchStart.bind(this);
        this.$onTouchMove = this.$onTouchMove.bind(this);
        this.$onTouchEnd = this.$onTouchEnd.bind(this);
        this.$onClick = this.$onClick.bind(this);
        this.$onInputChange = this.$onInputChange.bind(this);
        this.$onKeyUp = this.$onKeyUp.bind(this);
        this.$setHasOutline = this.$setHasOutline.bind(this);
        this.$unsetHasOutline = this.$unsetHasOutline.bind(this);
        this.$getInputRef = this.$getInputRef.bind(this);
      }
      if (Component)
        ReactSwitch3.__proto__ = Component;
      ReactSwitch3.prototype = Object.create(Component && Component.prototype);
      ReactSwitch3.prototype.constructor = ReactSwitch3;
      ReactSwitch3.prototype.componentDidMount = function componentDidMount() {
        this.$isMounted = true;
      };
      ReactSwitch3.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
        if (prevProps.checked === this.props.checked) {
          return;
        }
        var $pos = this.props.checked ? this.$checkedPos : this.$uncheckedPos;
        this.setState({
          $pos
        });
      };
      ReactSwitch3.prototype.componentWillUnmount = function componentWillUnmount() {
        this.$isMounted = false;
      };
      ReactSwitch3.prototype.$onDragStart = function $onDragStart(clientX) {
        this.$inputRef.focus();
        this.setState({
          $startX: clientX,
          $hasOutline: true,
          $dragStartingTime: Date.now()
        });
      };
      ReactSwitch3.prototype.$onDrag = function $onDrag(clientX) {
        var ref = this.state;
        var $startX = ref.$startX;
        var $isDragging = ref.$isDragging;
        var $pos = ref.$pos;
        var ref$1 = this.props;
        var checked = ref$1.checked;
        var startPos = checked ? this.$checkedPos : this.$uncheckedPos;
        var mousePos = startPos + clientX - $startX;
        if (!$isDragging && clientX !== $startX) {
          this.setState({
            $isDragging: true
          });
        }
        var newPos = Math.min(this.$checkedPos, Math.max(this.$uncheckedPos, mousePos));
        if (newPos !== $pos) {
          this.setState({
            $pos: newPos
          });
        }
      };
      ReactSwitch3.prototype.$onDragStop = function $onDragStop(event) {
        var ref = this.state;
        var $pos = ref.$pos;
        var $isDragging = ref.$isDragging;
        var $dragStartingTime = ref.$dragStartingTime;
        var ref$1 = this.props;
        var checked = ref$1.checked;
        var halfwayCheckpoint = (this.$checkedPos + this.$uncheckedPos) / 2;
        var prevPos = this.props.checked ? this.$checkedPos : this.$uncheckedPos;
        this.setState({
          $pos: prevPos
        });
        var timeSinceStart = Date.now() - $dragStartingTime;
        var isSimulatedClick = !$isDragging || timeSinceStart < 250;
        var isDraggedHalfway = checked && $pos <= halfwayCheckpoint || !checked && $pos >= halfwayCheckpoint;
        if (isSimulatedClick || isDraggedHalfway) {
          this.$onChange(event);
        }
        if (this.$isMounted) {
          this.setState({
            $isDragging: false,
            $hasOutline: false
          });
        }
        this.$lastDragAt = Date.now();
      };
      ReactSwitch3.prototype.$onMouseDown = function $onMouseDown(event) {
        event.preventDefault();
        if (typeof event.button === "number" && event.button !== 0) {
          return;
        }
        this.$onDragStart(event.clientX);
        window.addEventListener("mousemove", this.$onMouseMove);
        window.addEventListener("mouseup", this.$onMouseUp);
      };
      ReactSwitch3.prototype.$onMouseMove = function $onMouseMove(event) {
        event.preventDefault();
        this.$onDrag(event.clientX);
      };
      ReactSwitch3.prototype.$onMouseUp = function $onMouseUp(event) {
        this.$onDragStop(event);
        window.removeEventListener("mousemove", this.$onMouseMove);
        window.removeEventListener("mouseup", this.$onMouseUp);
      };
      ReactSwitch3.prototype.$onTouchStart = function $onTouchStart(event) {
        this.$checkedStateFromDragging = null;
        this.$onDragStart(event.touches[0].clientX);
      };
      ReactSwitch3.prototype.$onTouchMove = function $onTouchMove(event) {
        this.$onDrag(event.touches[0].clientX);
      };
      ReactSwitch3.prototype.$onTouchEnd = function $onTouchEnd(event) {
        event.preventDefault();
        this.$onDragStop(event);
      };
      ReactSwitch3.prototype.$onInputChange = function $onInputChange(event) {
        if (Date.now() - this.$lastDragAt > 50) {
          this.$onChange(event);
          if (Date.now() - this.$lastKeyUpAt > 50) {
            if (this.$isMounted) {
              this.setState({
                $hasOutline: false
              });
            }
          }
        }
      };
      ReactSwitch3.prototype.$onKeyUp = function $onKeyUp() {
        this.$lastKeyUpAt = Date.now();
      };
      ReactSwitch3.prototype.$setHasOutline = function $setHasOutline() {
        this.setState({
          $hasOutline: true
        });
      };
      ReactSwitch3.prototype.$unsetHasOutline = function $unsetHasOutline() {
        this.setState({
          $hasOutline: false
        });
      };
      ReactSwitch3.prototype.$getInputRef = function $getInputRef(el) {
        this.$inputRef = el;
      };
      ReactSwitch3.prototype.$onClick = function $onClick(event) {
        event.preventDefault();
        this.$inputRef.focus();
        this.$onChange(event);
        if (this.$isMounted) {
          this.setState({
            $hasOutline: false
          });
        }
      };
      ReactSwitch3.prototype.$onChange = function $onChange(event) {
        var ref = this.props;
        var checked = ref.checked;
        var onChange = ref.onChange;
        var id = ref.id;
        onChange(!checked, event, id);
      };
      ReactSwitch3.prototype.render = function render() {
        var ref = this.props;
        var checked = ref.checked;
        var disabled = ref.disabled;
        var className = ref.className;
        var offColor = ref.offColor;
        var onColor = ref.onColor;
        var offHandleColor = ref.offHandleColor;
        var onHandleColor = ref.onHandleColor;
        var checkedIcon2 = ref.checkedIcon;
        var uncheckedIcon2 = ref.uncheckedIcon;
        var checkedHandleIcon = ref.checkedHandleIcon;
        var uncheckedHandleIcon = ref.uncheckedHandleIcon;
        var boxShadow = ref.boxShadow;
        var activeBoxShadow = ref.activeBoxShadow;
        var height = ref.height;
        var width = ref.width;
        var borderRadius = ref.borderRadius;
        ref.handleDiameter;
        var rest$1 = objectWithoutProperties(ref, ["checked", "disabled", "className", "offColor", "onColor", "offHandleColor", "onHandleColor", "checkedIcon", "uncheckedIcon", "checkedHandleIcon", "uncheckedHandleIcon", "boxShadow", "activeBoxShadow", "height", "width", "borderRadius", "handleDiameter"]);
        var rest = rest$1;
        var ref$1 = this.state;
        var $pos = ref$1.$pos;
        var $isDragging = ref$1.$isDragging;
        var $hasOutline = ref$1.$hasOutline;
        var rootStyle = {
          position: "relative",
          display: "inline-block",
          textAlign: "left",
          opacity: disabled ? 0.5 : 1,
          direction: "ltr",
          borderRadius: height / 2,
          WebkitTransition: "opacity 0.25s",
          MozTransition: "opacity 0.25s",
          transition: "opacity 0.25s",
          touchAction: "none",
          WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
          WebkitUserSelect: "none",
          MozUserSelect: "none",
          msUserSelect: "none",
          userSelect: "none"
        };
        var backgroundStyle = {
          height,
          width,
          margin: Math.max(0, (this.$handleDiameter - height) / 2),
          position: "relative",
          background: getBackgroundColor($pos, this.$checkedPos, this.$uncheckedPos, offColor, onColor),
          borderRadius: typeof borderRadius === "number" ? borderRadius : height / 2,
          cursor: disabled ? "default" : "pointer",
          WebkitTransition: $isDragging ? null : "background 0.25s",
          MozTransition: $isDragging ? null : "background 0.25s",
          transition: $isDragging ? null : "background 0.25s"
        };
        var checkedIconStyle = {
          height,
          width: Math.min(height * 1.5, width - (this.$handleDiameter + height) / 2 + 1),
          position: "relative",
          opacity: ($pos - this.$uncheckedPos) / (this.$checkedPos - this.$uncheckedPos),
          pointerEvents: "none",
          WebkitTransition: $isDragging ? null : "opacity 0.25s",
          MozTransition: $isDragging ? null : "opacity 0.25s",
          transition: $isDragging ? null : "opacity 0.25s"
        };
        var uncheckedIconStyle = {
          height,
          width: Math.min(height * 1.5, width - (this.$handleDiameter + height) / 2 + 1),
          position: "absolute",
          opacity: 1 - ($pos - this.$uncheckedPos) / (this.$checkedPos - this.$uncheckedPos),
          right: 0,
          top: 0,
          pointerEvents: "none",
          WebkitTransition: $isDragging ? null : "opacity 0.25s",
          MozTransition: $isDragging ? null : "opacity 0.25s",
          transition: $isDragging ? null : "opacity 0.25s"
        };
        var handleStyle = {
          height: this.$handleDiameter,
          width: this.$handleDiameter,
          background: getBackgroundColor($pos, this.$checkedPos, this.$uncheckedPos, offHandleColor, onHandleColor),
          display: "inline-block",
          cursor: disabled ? "default" : "pointer",
          borderRadius: typeof borderRadius === "number" ? borderRadius - 1 : "50%",
          position: "absolute",
          transform: "translateX(" + $pos + "px)",
          top: Math.max(0, (height - this.$handleDiameter) / 2),
          outline: 0,
          boxShadow: $hasOutline ? activeBoxShadow : boxShadow,
          border: 0,
          WebkitTransition: $isDragging ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s",
          MozTransition: $isDragging ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s",
          transition: $isDragging ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s"
        };
        var uncheckedHandleIconStyle = {
          height: this.$handleDiameter,
          width: this.$handleDiameter,
          opacity: Math.max((1 - ($pos - this.$uncheckedPos) / (this.$checkedPos - this.$uncheckedPos) - 0.5) * 2, 0),
          position: "absolute",
          left: 0,
          top: 0,
          pointerEvents: "none",
          WebkitTransition: $isDragging ? null : "opacity 0.25s",
          MozTransition: $isDragging ? null : "opacity 0.25s",
          transition: $isDragging ? null : "opacity 0.25s"
        };
        var checkedHandleIconStyle = {
          height: this.$handleDiameter,
          width: this.$handleDiameter,
          opacity: Math.max((($pos - this.$uncheckedPos) / (this.$checkedPos - this.$uncheckedPos) - 0.5) * 2, 0),
          position: "absolute",
          left: 0,
          top: 0,
          pointerEvents: "none",
          WebkitTransition: $isDragging ? null : "opacity 0.25s",
          MozTransition: $isDragging ? null : "opacity 0.25s",
          transition: $isDragging ? null : "opacity 0.25s"
        };
        var inputStyle = {
          border: 0,
          clip: "rect(0 0 0 0)",
          height: 1,
          margin: -1,
          overflow: "hidden",
          padding: 0,
          position: "absolute",
          width: 1
        };
        return React2.createElement("div", {
          className,
          style: rootStyle
        }, React2.createElement("div", {
          className: "react-switch-bg",
          style: backgroundStyle,
          onClick: disabled ? null : this.$onClick,
          onMouseDown: function(e) {
            return e.preventDefault();
          }
        }, checkedIcon2 && React2.createElement("div", {
          style: checkedIconStyle
        }, checkedIcon2), uncheckedIcon2 && React2.createElement("div", {
          style: uncheckedIconStyle
        }, uncheckedIcon2)), React2.createElement("div", {
          className: "react-switch-handle",
          style: handleStyle,
          onClick: function(e) {
            return e.preventDefault();
          },
          onMouseDown: disabled ? null : this.$onMouseDown,
          onTouchStart: disabled ? null : this.$onTouchStart,
          onTouchMove: disabled ? null : this.$onTouchMove,
          onTouchEnd: disabled ? null : this.$onTouchEnd,
          onTouchCancel: disabled ? null : this.$unsetHasOutline
        }, uncheckedHandleIcon && React2.createElement("div", {
          style: uncheckedHandleIconStyle
        }, uncheckedHandleIcon), checkedHandleIcon && React2.createElement("div", {
          style: checkedHandleIconStyle
        }, checkedHandleIcon)), React2.createElement("input", _extends({}, {
          type: "checkbox",
          role: "switch",
          "aria-checked": checked,
          checked,
          disabled,
          style: inputStyle
        }, rest, {
          ref: this.$getInputRef,
          onFocus: this.$setHasOutline,
          onBlur: this.$unsetHasOutline,
          onKeyUp: this.$onKeyUp,
          onChange: this.$onInputChange
        })));
      };
      return ReactSwitch3;
    }(React2.Component);
    ReactSwitch2.propTypes = {
      checked: PropTypes.bool.isRequired,
      onChange: PropTypes.func.isRequired,
      disabled: PropTypes.bool,
      offColor: hexColorPropType,
      onColor: hexColorPropType,
      offHandleColor: hexColorPropType,
      onHandleColor: hexColorPropType,
      handleDiameter: PropTypes.number,
      uncheckedIcon: PropTypes.oneOfType([PropTypes.bool, PropTypes.element]),
      checkedIcon: PropTypes.oneOfType([PropTypes.bool, PropTypes.element]),
      boxShadow: PropTypes.string,
      borderRadius: PropTypes.number,
      activeBoxShadow: PropTypes.string,
      uncheckedHandleIcon: PropTypes.element,
      checkedHandleIcon: PropTypes.element,
      height: PropTypes.number,
      width: PropTypes.number,
      id: PropTypes.string,
      className: PropTypes.string
    };
    ReactSwitch2.defaultProps = {
      disabled: false,
      offColor: "#888",
      onColor: "#080",
      offHandleColor: "#fff",
      onHandleColor: "#fff",
      uncheckedIcon,
      checkedIcon,
      boxShadow: null,
      activeBoxShadow: "0 0 2px 3px #3bf",
      height: 28,
      width: 56
    };
    exports["default"] = ReactSwitch2;
  }
});

// node_modules/react-switch/index.js
var require_react_switch = __commonJS({
  "node_modules/react-switch/index.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_switch_dev();
    }
  }
});

// node_modules/react-darkreader/dist/index.esm.js
var import_react = __toESM(require_react());
var import_darkreader = __toESM(require_darkreader());
var import_react_switch = __toESM(require_react_switch());
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function useDarkreader() {
  var defaultDarken = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  var theme = arguments.length > 1 ? arguments[1] : void 0;
  var fixes = arguments.length > 2 ? arguments[2] : void 0;
  var _useState = (0, import_react.useState)(defaultDarken), _useState2 = _slicedToArray(_useState, 2), isDark = _useState2[0], setIsDark = _useState2[1];
  var defaultTheme = {
    brightness: 100,
    contrast: 90,
    sepia: 10
  };
  var defaultFixes = {
    invert: [],
    css: "",
    ignoreInlineStyle: [".react-switch-handle"],
    ignoreImageAnalysis: []
  };
  (0, import_react.useEffect)(function() {
    (0, import_darkreader.setFetchMethod)(window.fetch);
    isDark ? (0, import_darkreader.enable)(_objectSpread2(_objectSpread2({}, defaultTheme), theme), _objectSpread2(_objectSpread2({}, defaultFixes), fixes)) : (0, import_darkreader.disable)();
    return function() {
      (0, import_darkreader.disable)();
    };
  }, [isDark]);
  var action = (0, import_react.useMemo)(function() {
    var toggle = function toggle2() {
      return setIsDark(function(prevState) {
        return !prevState;
      });
    };
    return {
      toggle,
      collectCSS: import_darkreader.exportGeneratedCSS
    };
  }, [isDark]);
  return [isDark, action];
}
function styleInject(css, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z = "body{\n  color: rgba(0, 0, 0, 0.85);\n  background-color: #fff;\n}\n\n.react-switch .react-switch-icon{\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n}\n\n.react-switch-docusaurus .react-switch-icon{\n  font-size: 14px;\n}\n\n.react-switch > .react-switch-bg{\n  box-sizing: border-box;\n}\n\n.react-switch-github__light > .react-switch-bg{\n  border: 3px solid #d1d5da;\n}\n\n.react-switch-github__dark > .react-switch-bg{\n  border: 3px solid #3c1e70;\n}\n\n.react-switch-fluent__light > .react-switch-bg{\n  border: 1px solid #605e5c;\n}\n\n.react-switch-fluent__dark > .react-switch-bg{\n  border: 1px solid #0078d4;\n}\n\n";
styleInject(css_248z);
function Switch(SwitchProps) {
  if (SwitchProps.styling === "docusaurus") {
    return import_react.default.createElement(DocusaurusSwitch, Object.assign({}, SwitchProps));
  } else if (SwitchProps.styling === "material") {
    return import_react.default.createElement(MaterialSwitch, Object.assign({}, SwitchProps));
  } else if (SwitchProps.styling === "github") {
    return import_react.default.createElement(GithubSwitch, Object.assign({}, SwitchProps));
  } else if (SwitchProps.styling === "fluent") {
    return import_react.default.createElement(FluentSwitch, Object.assign({}, SwitchProps));
  } else {
    return import_react.default.createElement(DocusaurusSwitch, Object.assign({}, SwitchProps));
  }
}
function DocusaurusSwitch(reactSwitchProps) {
  return import_react.default.createElement(import_react_switch.default, Object.assign({
    className: "react-switch react-switch-docusaurus",
    handleDiameter: 20,
    onColor: "#4d4d4d",
    offColor: "#4d4d4d",
    onHandleColor: "#ffffff",
    offHandleColor: "#ffffff",
    boxShadow: "0px 1px 5px rgba(0, 0, 0, 0.6)",
    activeBoxShadow: "0 0 2px 3px #2c89a0",
    width: 50,
    height: 24,
    uncheckedIcon: import_react.default.createElement("span", {
      className: "react-switch-icon"
    }, "🌞"),
    checkedIcon: import_react.default.createElement("span", {
      className: "react-switch-icon"
    }, "🌜")
  }, reactSwitchProps));
}
function MaterialSwitch(reactSwitchProps) {
  return import_react.default.createElement(import_react_switch.default, Object.assign({
    className: "react-switch react-switch-material",
    onColor: "#ee80a7",
    onHandleColor: "#dc004e",
    handleDiameter: 18,
    uncheckedIcon: false,
    checkedIcon: false,
    boxShadow: "0px 1px 5px rgba(0, 0, 0, 0.6)",
    activeBoxShadow: "0px 0px 1px 10px rgba(0, 0, 0, 0.2)",
    height: 12,
    width: 34
  }, reactSwitchProps));
}
function GithubSwitch(reactSwitchProps) {
  var svg_month = import_react.default.createElement("span", {
    className: "react-switch-icon"
  }, import_react.default.createElement("svg", {
    fill: "#ffdf5d",
    "aria-hidden": "true",
    width: "14",
    height: "13",
    viewBox: "0 0 14 13",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react.default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z"
  })));
  return import_react.default.createElement(import_react_switch.default, Object.assign({
    className: "react-switch react-switch-github react-switch-github__".concat((reactSwitchProps === null || reactSwitchProps === void 0 ? void 0 : reactSwitchProps.checked) ? "dark" : "light"),
    onColor: "#271052",
    offColor: "#ffffff",
    onHandleColor: "#6e40c9",
    offHandleColor: "#2f363d",
    handleDiameter: 28,
    uncheckedIcon: false,
    checkedIcon: false,
    uncheckedHandleIcon: svg_month,
    checkedHandleIcon: svg_month,
    boxShadow: "0px 1px 5px rgba(0, 0, 0, 0.6)",
    activeBoxShadow: "0px 0px 1px 4px rgba(0, 0, 0, 0.2)",
    height: 24,
    width: 42
  }, reactSwitchProps));
}
function FluentSwitch(reactSwitchProps) {
  return import_react.default.createElement(import_react_switch.default, Object.assign({
    className: "react-switch react-switch-fluent react-switch-fluent__".concat((reactSwitchProps === null || reactSwitchProps === void 0 ? void 0 : reactSwitchProps.checked) ? "dark" : "light"),
    handleDiameter: 12,
    onColor: "#0078d4",
    offColor: "#ffffff",
    onHandleColor: "#ffffff",
    offHandleColor: "#605e5c",
    activeBoxShadow: "0 0 2px 3px #2c89a0",
    width: 40,
    height: 20,
    uncheckedIcon: false,
    checkedIcon: false
  }, reactSwitchProps));
}
function Darkreader(_ref) {
  var _ref$defaultDarken = _ref.defaultDarken, defaultDarken = _ref$defaultDarken === void 0 ? false : _ref$defaultDarken, theme = _ref.theme, fixes = _ref.fixes, _onChange = _ref.onChange;
  var _useDarkreader = useDarkreader(defaultDarken, theme, fixes), _useDarkreader2 = _slicedToArray(_useDarkreader, 2), isDark = _useDarkreader2[0], toggle = _useDarkreader2[1].toggle;
  return import_react.default.createElement(Switch, {
    checked: isDark,
    onChange: function onChange(checked) {
      toggle();
      _onChange === null || _onChange === void 0 ? void 0 : _onChange(checked);
    }
  });
}
var index_esm_default = Darkreader;
export {
  Switch,
  index_esm_default as default,
  useDarkreader
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=react-darkreader.js.map
